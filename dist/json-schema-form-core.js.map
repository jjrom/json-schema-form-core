{"version":3,"sources":["webpack:///webpack/bootstrap 38299528ac98a91f6af1","webpack:///./src/lib/sf-path.js","webpack:///./src/lib/canonical-title-map.js","webpack:///./~/objectpath/index.js","webpack:///./src/lib/schema-defaults.js","webpack:///./src/module.js","webpack:///node_modules/browser-pack/_prelude.js","webpack:///index.js","webpack:///node_modules/component-emitter/index.js","webpack:///node_modules/native-promise-only/lib/npo.src.js","webpack:///node_modules/path-browserify/index.js","webpack:///node_modules/path-loader/index.js","webpack:///node_modules/path-loader/lib/loaders/file-browser.js","webpack:///node_modules/path-loader/lib/loaders/http.js","webpack:///node_modules/process/browser.js","webpack:///node_modules/querystring-es3/decode.js","webpack:///node_modules/querystring-es3/encode.js","webpack:///node_modules/querystring-es3/index.js","webpack:///node_modules/reduce-component/index.js","webpack:///node_modules/slash/index.js","webpack:///node_modules/superagent/lib/client.js","webpack:///node_modules/superagent/lib/is-object.js","webpack:///node_modules/superagent/lib/request-base.js","webpack:///node_modules/superagent/lib/request.js","webpack:///node_modules/uri-js/build/punycode.js","webpack:///node_modules/uri-js/build/schemes.js","webpack:///node_modules/uri-js/build/schemes/http.js","webpack:///node_modules/uri-js/build/schemes/mailto.js","webpack:///node_modules/uri-js/build/schemes/urn.js","webpack:///node_modules/uri-js/build/uri.js","webpack:///./src/lib/merge.js","webpack:///./src/lib/resolve.js","webpack:///./src/lib/select.js","webpack:///./src/lib/traverse.js","webpack:///./src/lib/validate.js","webpack:///./~/objectpath/lib/ObjectPath.js","webpack:///./~/tv4/tv4.js"],"names":["name","key","separator","formName","omitNumbers","fieldKey","slice","fieldSeparator","filter","currentKey","length","join","titleMap","originalEnum","Array","isArray","canonical","forEach","value","push","Object","keys","stripNullType","type","enumToTitleMap","enm","defaultFormDefinition","schemaTypes","schema","options","rules","def","innerDefaultFormDefinition","childName","childSchema","childOptions","i","assign","stdFormObj","f","global","formDefaults","supressPropertyTitles","title","description","required","maxLength","maxlength","minLength","minlength","readOnly","readonly","minimum","exclusiveMinimum","maximum","exclusiveMaximum","validationMessage","enumNames","canonicalTitleMap","format","ngModelOptions","text","path","lookup","stringify","number","integer","checkbox","select","geotypes","indexOf","replace","console","log","checkboxes","items","fieldset","defaultFormDef","properties","ignore","array","arrPath","createDefaults","string","object","boolean","defaultForm","defaultSchemaTypes","globalOptions","form","Error","sfPath","sfPathImp","schemaDefaults","schemaDefaultsImp","canonicalTitleMapImp","merge","typeDefaults","asyncTemplates","formItems","formItemRest","idx","stdForm","idxRest","hasOwnProperty","defaultFormLookup","concat","formKeys","map","obj","element","undefined","isInside","parse","strid","attr","tabs","tab","default","template","templateUrl","jsonref","callBack","promise","Promise","resolve","reject","JsonRefs","then","res","resolved","catch","err","error","numRe","projection","valueToSet","parts","test","tmp","traverseSchema","fn","ignoreArrays","traverse","schemaObject","processorFunction","pathArray","currentPath","traverseForm","validate","valid","wrap","propName","valueWrap","tv4","validateResult"],"mappings":"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CA;AACA;AACA,WAFA;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAFA,MAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WARA,MAQA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4EACA,yCADA,GACA,KADA,GACA,EADA,IACA,8BADA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WANA;AAOA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAFA,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAVA,MAUA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WALA,MAKA;AACA;;AAEA;AACA;AACA,aAFA,MAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAJA;;AAMA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAHA,MAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oCACA,IADA,CACA;AACA,8DACA,IADA,CACA;AACA,wDACA,GADA,EAEA,sDACA,EADA,GAEA,sDAJA,EAKA,UALA,EAMA,OANA,EAOA,wBAPA,EAQA,6BARA,EASA,OATA,EAUA,QAVA;AAWA,mBAbA,EAcA,KAdA,CAcA;AACA;AACA;AACA,mBAjBA;AAkBA,iBApBA;AAqBA,eAtBA,MAsBA;AACA,2FACA,uCADA,IACA,sBADA,EACA;AACA;AACA,wCACA,IADA,CACA;AACA,yDACA,GADA,EAEA,qBAFA,EAGA,UAHA,EAIA,OAJA,EAKA,wBALA,EAMA,6BANA,EAOA,OAPA,EAQA,8EARA;AASA,qBAXA;AAYA;AACA,iBAhBA,MAgBA;AACA;AACA;AACA;AACA,aA5CA,MA4CA;AACA;AACA;AACA;AACA,eAFA;;AAIA;AACA;AACA;AACA,SAhGA;;AAkGA,4BACA,IADA,CACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kGACA,6BADA,IACA,kBADA,IACA,gCADA,EACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAJA;AAKA,iBANA,MAMA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAnBA;AAoBA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAPA;;AASA;AACA;;AAEA;AACA;AACA;AACA,WANA;AAOA,SA9CA,EA+CA,IA/CA,CA+CA;AACA;AACA,SAjDA;;AAmDA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA,SARA;;AAUA;AACA;;AAEA;AACA;AACA;AACA,SAFA;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;;AAYA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAFA;AAGA;;AAEA;AACA;;AAEA;AACA,8BACA,IADA,CACA;AACA;AACA;AADA;;AAIA;AACA,WAPA,EAQA,KARA,CAQA;AACA;AACA;AADA;;AAIA;AACA,WAdA;AAeA,SA3BA,MA2BA;AACA;AACA;AACA;AACA,WAFA;AAGA;;AAEA;AACA;AACA;AACA,SAFA;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA,SANA,CAMA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAFA,MAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAHA;AAIA,SANA,MAMA;AACA;AACA,SAFA,MAEA;AACA;AACA;AACA,WAFA;AAGA;;AAEA;AACA;AACA,SAFA;AAGA;;AAEA;AACA;;AAEA;AACA;AACA,SAFA,MAEA;AACA;AACA,SAFA,MAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAFA;AAGA,aAJA,MAIA;AACA;AACA;AACA,eAFA;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAHA,MAGA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAFA,MAEA,4CACA,gCADA,IAEA,mCAFA,IAGA,iCAHA,EAGA;AACA;AACA,SALA,MAKA,oDACA,0CADA,EACA;AACA;AACA,SAHA,MAGA,qDACA,4CADA,EACA;AACA;AACA,SAHA,MAGA,sDACA,6CADA,EACA;AACA;AACA,SAHA,MAGA,gDACA,oCADA,IAEA,0BAFA,EAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAFA,CAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;;;;;;;;;;;AAWA;;;;;;;;;;;AAWA;;;;;;;;;;;AAWA;;;;;;;;;;;;AAYA;;;;;;;;;;AAUA;;;;;;;;AAQA;;;;;;;;;;;;;AAaA;;;;;;;;;;;;;;;;;AAiBA;;;;;AAKA;AACA;AACA;;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SANA;AAOA;;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SANA;AAOA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qDACA,kCADA,EAEA,yBAFA,EAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAhCA;;AAkCA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA;AACA;;AAEA,4BACA,IADA,CACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAdA,EAeA,IAfA,CAeA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAFA,MAEA;AACA;AACA;;AAEA;AACA;AACA,yCADA;AAEA;AAFA;AAIA,SA9CA;;AAgDA;AACA;;AAEA;;;;;;;;;AASA;AACA;AACA;AADA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAFA,MAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAxBA,MAwBA;AACA;AACA;AACA,SA5BA,CA4BA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAFA,MAEA;AACA;AACA,eAFA,MAEA;AACA;AACA;AACA;AACA,WAZA,MAYA;AACA;AACA;AACA,SAhBA,CAgBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmCA;AACA;AACA;;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;;AAEA,4BACA,IADA,CACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAZA,EAaA,IAbA,CAaA;AACA;AACA,yBADA;AAEA;AAFA;AAIA,SAlBA,EAmBA,IAnBA,CAmBA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAFA,MAEA;AACA;AACA;AACA,iBAFA,MAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAlBA,MAkBA;AACA;AACA;AACA;AACA,WAjCA;;AAmCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iBAPA,CAOA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAnBA;AAoBA,WAxBA;;AA0BA;AACA,sBADA;AAEA;AAFA;AAIA,SA9FA;;AAgGA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACA;;AAEA,4BACA,IADA,CACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,SAdA,EAeA,IAfA,CAeA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4CACA,IADA,CACA;AACA;AACA,6BADA;AAEA,qCAFA;AAGA;AAHA;AAKA,WAPA;AAQA,SAnCA;;AAqCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;KDp2CA,E,uGAAA,G;;AECA;;;;AAIA;;AAEA;;;;;;AAMA;AACA;AACA;;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AASA,6BACA;AACA;AACA,4EACA,IADA,CACA,EADA;AAEA;AACA,OANA;;AAQA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OATA;;AAWA;;;;;;;;;;AAUA,8BACA,mCACA,uCACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAhCA;;AAkCA;;;;;;;;AAQA;AACA;AACA;AAAA,YACA,wCADA;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAbA;;AAeA;;;;;;;;AAQA;AACA;AACA;AACA,OAHA;;AAKA;;;;;;;;AAQA;AACA;AACA,OAFA;UF9JA,E;;AGAA;;;;;AAKA;AACA;AACA;AACA;AAAA;AAAA,iBACA;AAAA;AAAA;AAAA;AAAA;AACA,SALA,EAKA,SALA,EAKA,4CALA,EAKA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA,cACA,oCADA;AAAA,cAEA,6CACA;AAAA;AAAA,WADA,GAEA,UAJA;;AAOA;AACA;AACA;AACA;AACA;AACA,0BADA;AAEA,8BAFA;AAGA;AAHA;AAKA,aANA;AAOA,WATA,CAUA;AACA;AACA;AACA;AACA,aAHA;AAIA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAFA,MAGA;AACA;AACA;AACA;AACA;AACA,eAXA;AAYA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AApBA;AAsBA,WA/BA;;AAiCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;;AAEA,8BAEA,0CAFA,GAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BACA,IADA,EAEA,gEAFA,EAGA,aAHA;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAFA,MAGA;AACA;AACA;AACA,iBAFA,MAGA;AACA;AACA;;AAEA;AACA;AACA,iBAFA,MAGA;AACA;AACA,iBAFA,MAGA;AACA;AACA;AACA;AACA,aAtBA,CAuBA;AACA;AACA;AACA;;AAEA;AACA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCACA;AAAA;AAAA,qBADA,EAEA;AAAA;AAAA,qBAFA;AAIA,mBALA,CAMA;AACA;AACA;AACA,iBAXA;AAYA,eAbA,MAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAtBA,CAuBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CACA,IADA,CAEA;AACA;AACA,iBAJA,EAKA,QALA;AAOA,eARA,EAQA,GARA;AASA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,sEADA;AAEA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAPA;AAQA;;AAEA;AACA;AACA;;AAEA;AACA,aAvBA;AAwBA;AACA;AACA,aAFA;;AAIA;AACA,4BACA,MADA,EAEA;AACA;AACA,eAJA,EAKA;AACA;AACA,eAPA;AASA,aAVA,CAWA;AACA;AACA;AACA;;AAEA;AACA,gCADA;;AAIA;AACA;;AAEA;AACA;AACA,gCADA;;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aANA;AAOA,WAhBA;;AAkBA;AACA;AACA;AACA;AACA;;AAEA;AACA,aANA;AAOA,WARA;;AAUA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,eALA,EAKA,MALA;AAMA,aAbA;AAcA,WAzBA;;AA2BA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAFA,EAEA,MAFA;AAGA,aARA;AASA,WAjBA;;AAmBA;AACA,SA/WA;;UHLA,E;;AIAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAFA,MAEA;AACA;AACA;AACA,aAHA,MAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BACA,+DADA;AAEA;AACA;AACA,SAFA;;AAIA;AACA;AACA;AACA;AAAA,cACA,wBADA;;AAGA;AACA;;AAEA;AACA;AACA;AACA,aAFA,MAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAFA,GAEA,iBAFA,EAEA,IAFA,CAEA,GAFA;;AAIA;AACA,SA3BA;;AA6BA;AACA;AACA;AACA;AAAA,cACA,wCADA;;AAGA;AACA;AACA;AACA,WAFA,GAEA,WAFA,EAEA,IAFA,CAEA,GAFA;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAjBA;;AAmBA;AACA;AACA;AACA,SAFA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WALA,EAKA,IALA,CAKA,GALA;AAMA,SARA;;AAWA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,SAvCA;;AAyCA;AACA;;AAEA;AACA;AAAA,cACA,gBADA;AAAA,cAEA,eAFA;;AAIA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAhBA;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAPA;;AAUA;AACA;AACA,SAFA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+CACA;AAAA;AAAA,SADA,GAEA;AACA;AACA;AACA,SALA;;yBJzNA,E;AKAA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;AAEA;;;;;;AAMA;AACA,2CADA;AAEA,2CAFA;AAGA;AAHA;AAKA,gJACA,qBADA,GAEA,qBAFA;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;AAYA;;;;;;;;;;;;;;;AAeA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAFA,MAEA;AACA;AACA;AACA;AACA,SAdA;;AAgBA;AACA,4BACA,IADA,CACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAFA,MAEA;AACA;AACA;AACA,aANA;AAOA,WAVA;AAWA,SAbA,EAcA,IAdA,CAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAFA,MAEA;AACA;AACA;AACA,eANA;AAOA,aAVA;AAWA,WAZA,MAYA;AACA;AACA;AACA;AACA;AACA,SAhCA;;AAkCA;AACA,OA7DA;sFLvKA,E;AMAA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;AAEA;;AAEA;;;;;AAKA;AACA;AACA,OAFA;;AAIA;;;AAGA;AACA;;AAEA;AACA;AACA,SAFA,MAEA;AACA;AACA;AACA,OARA;UNxCA,E;AOAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;AAEA;;AAEA;;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA;AACA;;AAEA,gBACA,GADA,CACA;AACA;AACA;AACA,eAFA,MAEA;AACA;AACA;AACA,aAPA;AAQA;AACA;;AAEA;AACA;AACA;AACA,WAFA,MAEA;AACA,kFACA,yEADA,GACA,MADA,GAEA,qDAFA;AAGA;AACA,SARA,MAQA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAFA,CAEA;AACA;AACA;AACA,WANA,MAMA;AACA;AACA;AACA,SAZA,MAYA;AACA;AACA;AACA,OApDA;4BP3CA,E;AQAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAFA,MAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAXA;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAFA;AAGA;AACA;AACA;AACA;AACA,2B,CAAA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAFA;;AAIA;AAAA;AAAA;AACA;AACA;AACA,OAFA;AAGA;AAAA;AAAA;UR1FA,E;ASAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA,cACA,mBADA;AAAA,cAEA,IAFA;AAAA,cAEA,IAFA;AAAA,cAEA,CAFA;AAAA,cAEA,CAFA;;AAIA;AACA;AACA;AACA,WAHA,MAGA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAFA,MAEA;AACA;AACA,WAFA,MAEA;AACA;AACA;AACA;;AAEA;AACA,OAjDA;;AAmDA;AACA;AACA,OAFA;UTjFA,E;AUAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AAXA;AAaA,OAdA;;AAgBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAFA,EAEA,IAFA,CAEA,GAFA;AAGA,aAJA,MAIA;AACA;AACA;AACA,WATA,EASA,IATA,CASA,GATA;AAWA;;AAEA;AACA,mEACA,2CADA;AAEA,OAxBA;;AA0BA;AACA;AACA,OAFA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OANA;UV9EA,E;AWAA;;AAEA;AACA;yCXHA,E;;AYCA;;;;;;;;;;AAUA;AACA;AACA;AACA,2CACA,OADA,GAEA,UAFA;;AAIA;AACA;AACA;;AAEA;AACA,OAZA;UZXA,E;AaAA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OATA;UbDA,E;AcAA;;;;AAIA;AACA;AACA;AACA;;AAEA;;;;AAIA;AACA;AAAA;AACA;AACA,OAFA,MAEA;AAAA;AACA;AACA,OAFA,MAEA;AAAA;AACA;AACA;;AAEA;;;;AAIA;;AAEA;;;;;;;;;;;AAWA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;AAEA;;;;AAIA;;AAEA;;;;AAIA;AACA,oCACA,uDACA,mBAFA,GAEA;AACA;AACA,SAJA,MAIA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA,OAZA;;AAcA;;;;;;;;AAQA,2BACA;AAAA;AAAA,OADA,GAEA;AAAA;AAAA,OAFA;;AAIA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA,WAFA;AAGA;AACA,6CACA,GADA,GACA,uBADA;AAEA;;AAEA;;;;AAIA;;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;AAIA;;AAEA;;;;;;;AAOA;AACA,yBADA;AAEA,gCAFA;AAGA,8BAHA;AAIA,uDAJA;AAKA,mDALA;AAMA;AANA;;AASA;;;;;;;;;AASA;AACA,sDADA;AAEA;AAFA;;AAKA;;;;;;;;;AASA;AACA,wDADA;AAEA;AAFA;;AAKA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBARA,CAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AAQA;AACA;AAAA;AACA;;AAEA;;;;;;;;AAQA;AACA;AACA;;AAEA;;;;;;;;AAQA;AACA;AACA;AAAA,cACA,mBADA;AAAA,cAEA,mBAFA;;AAIA;AACA;AACA,SAPA,EAOA,EAPA;AAQA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;AACA;AACA;AACA;AACA;AACA,sKACA,qBADA,GAEA,IAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDACA,yDADA,GAEA,IAFA;AAGA;;AAEA;;;;;;;;AAQA;AACA;AACA,OAFA;;AAIA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA,OARA;;AAUA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA,uEACA,UADA,GAEA,IAFA;AAGA,OARA;;AAUA;;;;;;;;;;;;;;;;;;;;;AAqBA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8CACA,cADA,GAEA,KAFA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OA7BA;;AA+BA;;;;;;;AAOA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAZA;;AAcA;;;;AAIA;;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA,yBALA,CAKA;AACA,0BANA,CAMA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAFA,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAjCA;AAkCA;;AAEA;;;;AAIA;AACA;AACA;AACA;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAPA;;AASA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AACA;AACA,OAHA;;AAKA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA,OAHA;;AAKA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AACA;AACA,OAHA;;AAKA;;;;;;;;;;AAUA;AACA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AATA;AAWA;AACA,OAnBA;;AAqBA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA,OAJA;;AAMA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA,OAHA;;AAKA;AACA;AACA;AACA;AACA;AACA,OALA;;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAJA,MAIA;AACA;AACA;AACA;AACA,sCACA,uBADA,GAEA,IAFA;AAGA,WAJA,MAIA;AACA;AACA;AACA,SAVA,MAUA;AACA;AACA;;AAEA;AACA;AACA;AACA,OA1BA;;AA4BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,OANA;;AAQA;AACA;AACA;AACA,OAHA;;AAKA;;;;;;;;;AASA;AACA;AACA;AACA;AACA,OAJA;;AAMA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OATA;;AAWA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA,OALA;;AAOA;;;;;;;;;;;AAWA;AACA;AACA;AACA,OAHA;;AAKA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAdA;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SANA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAJA,CAIA,WAIA;AAHA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAHA,EAGA,OAHA;AAIA;;AAEA;AACA;AACA;AACA,+CACA,WADA,GAEA,WAFA;AAGA;;AAEA;AACA;AACA;AACA,SAFA,MAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OApGA;;AAuGA;;;;AAIA;;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA,OANA;;AAQA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA,OANA;;AAQA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA,OANA;;AAQA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA,OANA;;AAQA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA,OANA;gGd9iCA,E;AeAA;;;;;;;;AAQA;AACA;AACA;;AAEA;UfZA,E;AgBAA;;;AAGA;;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA,OAJA;;AAMA;;;;;;;;;AASA;AACA;AACA;AACA,OAHA;;AAKA;;;;;;;;AAQA;AACA;AACA;AACA,OAHA;;AAKA;;;;;;;;AAQA;AACA;AACA;AACA,SAFA;AAGA,OAJA;;AAMA;;;;AAIA;AACA;AACA;AACA,OAHA;;AAMA;;;;;;;;;AASA;AACA;AACA,OAFA;;AAIA;;;;;;;;;;;;AAYA;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAVA;;AAYA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA,OAJA;;AAMA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA,OAHA;6BhBlKA,E;AiBAA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;UjB/BA,E;AkBAA;;AAEA;;AAEA;;;;;AAKA;;;AAEA;AACA,2BAHA;AAAA,YAGA;;AAEA;AACA,iBANA;AAAA,YAOA,QAPA;AAAA,YAQA,SARA;AAAA,YASA,SATA;AAAA,YAUA,UAVA;AAAA,YAWA,gBAXA;AAAA,YAYA,cAZA;AAAA,YAYA;AACA,uBAbA;AAAA,YAaA;;AAEA;AACA,+BAhBA;AAAA,YAiBA,8BAjBA;AAAA,YAiBA;AACA,qDAlBA;AAAA,YAkBA;;AAEA;AACA;AACA,uEADA;AAEA,uEAFA;AAGA;AAHA,SArBA;;;AA2BA;AACA,mCA5BA;AAAA,YA6BA,kBA7BA;AAAA,YA8BA,wCA9BA;;;AAgCA;AACA,WAjCA;;AAmCA;;AAEA;;;;;;AAMA;AACA;AACA;;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;AAaA;AACA;AAAA,cACA,WADA;AAAA,cAEA,sBAFA;AAAA,cAGA,KAHA;AAAA,cAIA,KAJA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA,eAFA,MAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAXA,MAWA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WATA,EASA,IATA,CASA,EATA;AAUA;;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AAOA;AACA;AACA;AAAA,cACA,0BADA;AAAA,cAEA,GAFA;AAAA,cAGA,KAHA;AAAA,cAIA,YAJA;AAAA,cAKA,kBALA;AAAA,cAMA,KANA;AAAA,cAOA,CAPA;AAAA,cAQA,KARA;AAAA,cASA,IATA;AAAA,cAUA,CAVA;AAAA,cAWA,CAXA;AAAA,cAYA,KAZA;AAAA,cAaA,CAbA;;AAcA;AACA,oBAfA;;AAiBA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;;AAEA;;;;;;;AAOA;AACA;AAAA,cACA,KADA;AAAA,cAEA,cAFA;AAAA,cAGA,WAHA;AAAA,cAIA,IAJA;AAAA,cAKA,CALA;AAAA,cAMA,CANA;AAAA,cAOA,CAPA;AAAA,cAQA,CARA;AAAA,cASA,CATA;AAAA,cAUA,YAVA;AAAA,cAWA,WAXA;;AAYA;AACA,qBAbA;;AAcA;AACA,+BAfA;AAAA,cAgBA,UAhBA;AAAA,cAiBA,OAjBA;;AAmBA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BACA,6DADA;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;AAWA;AACA;AACA,gDACA,qCADA,GAEA,MAFA;AAGA,WAJA;AAKA;;AAEA;;;;;;;;;;;AAWA;AACA;AACA,gDACA,uBADA,GAEA,MAFA;AAGA,WAJA;AAKA;;AAEA;;AAEA;AACA;AACA;;;;;AAKA,0BANA;AAOA;;;;;;;AAOA;AACA,8BADA;AAEA;AAFA,WAdA;AAkBA,wBAlBA;AAmBA,wBAnBA;AAoBA,0BApBA;AAqBA;AArBA;;AAwBA;AACA,OA5eA;;AA8eA;UlBhfA,E;AmBAA;AACA;AACA;AACA;6EnBHA,E;AoBAA;AACA,0GACA;AACA;AACA,wBADA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SARA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;wBpBHA,E;AqBAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WARA,MASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AACA;AACA,kJAFA;AAAA,YAEA,wBAFA;AAAA,YAEA,0NAFA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAdA;AAAA,YAcA,sEAdA;AAAA,YAcA,sCAdA;AAAA,YAcA,4EAdA;AAAA,YAcA,uCAdA;AAAA,YAcA,gDAdA;AAAA,YAcA,wDAdA;;AAeA;AACA,mDAhBA;AAAA,YAgBA,qDAhBA;AAAA,YAgBA,wEAhBA;AAAA,YAgBA,6EAhBA;AAAA,YAgBA,2DAhBA;AAAA,YAgBA,kDAhBA;AAAA,YAgBA,2DAhBA;AAAA,YAgBA,8BAhBA;AAAA,YAgBA,kBAhBA;AAAA,YAgBA,4CAhBA;AAAA,YAgBA,2DAhBA;AAAA,YAgBA,oCAhBA;AAAA,YAgBA,2FAhBA;AAAA,YAgBA,0CAhBA;AAAA,YAgBA,2CAhBA;AAAA,YAgBA,kFAhBA;AAAA,YAgBA,8FAhBA;AAAA,YAgBA,uEAhBA;AAAA,YAgBA,wBAhBA;AAAA,YAgBA,wDAhBA;AAAA,YAgBA,mEAhBA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAFA,MAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA,kCACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAFA,CAGA;AACA;AACA;AACA,eARA,MASA;AACA;AACA;AACA;AACA;AACA;AACA,WA1DA;AA2DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAFA,CAGA;AACA;AACA;AACA,iBARA,MASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCACA;AACA,iCACA;AACA;AACA;AACA;AACA,kJACA,GADA,GAEA,6HAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AArGA;AAuGA,OAxJA;2CrBJA,E;AsBAA;AACA,0GACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAHA;AAIA;AAJA;AAMA;AACA;AACA;AACA;AACA,aAjBA,MAkBA;AACA;AACA;AACA;AACA,WA/BA;AAgCA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3CA;AA6CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WANA;AAOA;AACA;AACA;AACA;AACA;AACA,aAHA,MAIA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAoBA,OArEA;wBtBHA,E;AuBAA;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AACA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WARA,MASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA,0GADA;AAEA,sFAFA;AAGA,yFAHA;AAIA,kFAJA;AAKA,2FALA;AAMA,iGANA;AAOA,iHAPA;AAQA,wGARA;AASA,6EATA;AAUA,qDAVA;AAWA,mFAXA;AAYA;AAZA;AAcA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA,sBACA,wCADA,KAEA,aACA,uCADA,KAEA,cACA,sGADA,KAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,aAHA,MAIA;AACA;AACA;AACA;AACA,eAHA,MAIA;AACA;AACA;AACA;AACA,aATA,MAUA;AACA;AACA;AACA;AACA;AACA,eAJA,MAKA;AACA;AACA;AACA;AACA,aAVA,MAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCACA;AACA,iDACA;AACA,6CACA;AACA,6CACA;AACA,8CACA;AACA,iDACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA,8CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAHA,MAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCACA;AACA;AACA;AACA,WAlBA,MAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAdA,MAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAFA,MAGA;AACA;AACA,aAFA,MAGA;AACA;AACA,aAFA,MAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAFA,CAGA;AACA;AACA;AACA;AACA;AACA;AACA,aAbA,MAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAzEA,MA0EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA,aAFA,MAGA;AACA;AACA,aAFA,MAGA;AACA;AACA;AACA,aAHA,MAIA;AACA;AACA,aAFA,MAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,wDACA;AACA;AACA;AACA;AACA;AACA;AACA,aAFA,CAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CADA,CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCApDA,CAoDA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA,4DADA,CACA;AACA,oEAFA,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WARA,MASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAPA,MAQA;AACA;AACA;AACA;AACA;AACA,iBAFA,MAGA;AACA;AACA;AACA,eARA,MASA;AACA;AACA;AACA,iBAFA,MAGA;AACA;AACA;AACA,mBAFA,MAGA;AACA;AACA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CA;AACA;AACA,GAAG;;AAEH,yCAAyC;AACzC;AACA;;AAEA;AACA;;AAEA;;AAEA,8BAA8B,iGAAiG,EAAE;AACjI,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,KAAK,IAA0C;AAC/C,EAAE,kCAAO;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AAAA,oGAAC;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;;;;;;ACnHD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM,IAA0C;AAChD;AACA,IAAI,iCAAO,EAAE,oCAAE,OAAO;AAAA;AAAA;AAAA,oGAAC;AACvB,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE,yBAAyB;AAC3B,aAAa;AACb,gBAAgB;AAChB;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,kBAAkB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,yCAAyC;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,sBAAsB;AAC3E,EAAE;AACF,qDAAqD,qCAAqC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gCAAgC;AACjD;AACA;AACA;AACA,wDAAwD,0BAA0B;AAClF,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA,mDAAmD,iDAAiD;AACpG;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA,oDAAoD,mEAAmE;AACvH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oCAAoC;AAC/F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,qCAAqC;AAC5F;AACA;AACA,iEAAiE,qCAAqC;AACtG;AACA;AACA;AACA;AACA,uDAAuD,qCAAqC;AAC5F;AACA;AACA,iEAAiE,qCAAqC;AACtG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2DAA2D,YAAY;AACvE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,+CAA+C;AAC3G;AACA;AACA;AACA;AACA,2DAA2D,+CAA+C;AAC1G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,wBAAwB;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4DAA4D,8CAA8C;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,8CAA8C;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC,sBAAsB,iBAAiB;AACvC;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mEAAmE,0DAA0D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,0DAA0D;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,SAAS;AAClF;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,0BAA0B;AAC5F;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,gBAAgB;AACpC;AACA;AACA,mEAAmE,kCAAkC;AACrG;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,yDAAyD,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK,KAAK;AAC9C;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,YAAY,SAAS;AACzD,qCAAqC,MAAM;AAC3C;AACA;AACA,uFAAuF,OAAO,MAAM,OAAO;AAC3G;AACA;AACA,6BAA6B,MAAM,uBAAuB,WAAW;AACrE,yBAAyB,MAAM,uBAAuB,QAAQ;AAC9D,mCAAmC,MAAM,gCAAgC,QAAQ;AACjF,yBAAyB,MAAM,0BAA0B,QAAQ;AACjE,mCAAmC,MAAM,gCAAgC,QAAQ;AACjF,8BAA8B,MAAM;AACpC;AACA,6CAA6C,OAAO,kBAAkB,QAAQ;AAC9E,2CAA2C,OAAO,kBAAkB,QAAQ;AAC5E,kDAAkD,QAAQ;AAC1D;AACA,0DAA0D,cAAc,YAAY,QAAQ;AAC5F,2DAA2D,cAAc,YAAY,QAAQ;AAC7F,+CAA+C,IAAI;AACnD;AACA,8DAA8D,QAAQ,eAAe,IAAI;AACzF;AACA,2CAA2C,OAAO,YAAY,QAAQ;AACtE,yCAAyC,OAAO,YAAY,QAAQ;AACpE,qDAAqD,OAAO,MAAM,OAAO;AACzE;AACA;AACA,4CAA4C,QAAQ;AACpD,mCAAmC,IAAI,GAAG,QAAQ;AAClD;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,WAAW;;AAEX,CAAC,G","file":"json-schema-form-core.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 13);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 38299528ac98a91f6af1","export { parse } from 'objectpath';\nexport { stringify } from 'objectpath';\nexport { normalize } from 'objectpath';\n\n/**\n * I am a name formatter function for processing keys into names for classes or Id.\n *\n * @param  {Array<string>} key         I am the key array of a processed schema key\n * @param  {string}        separator   I am the separator between the key items and optional form name\n * @param  {string}        formName    I am an optional form name\n * @param  {boolean}       omitNumbers I determine if numeric values should be included in the output or withheld\n *\n * @return {string}                    I am the formatted key\n */\nexport function name (key: Array<string>, separator?: string, formName = '', omitNumbers = false) {\n  if (key) {\n    let fieldKey = key.slice();\n    let fieldSeparator = separator || '-';\n\n    if (omitNumbers) {\n      fieldKey = fieldKey.filter(function(currentKey: any) {\n        return typeof currentKey !== 'number';\n      });\n    };\n\n    return ((formName.length !== 0)\n      ? formName + fieldSeparator\n      : ''\n    ) + fieldKey.join(fieldSeparator);\n  };\n\n  return '';\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/sf-path.js","// Takes a titleMap in either object or list format and returns one\n// in the list format.\nexport default function(titleMap: Array<any>, originalEnum?: any) {\n  if (!Array.isArray(titleMap)) {\n    const canonical = [];\n    if (originalEnum) {\n      originalEnum.forEach((value) => {\n        canonical.push({ name: titleMap[value], value });\n      });\n    }\n    else {\n      Object.keys(titleMap).forEach((value) => {\n        canonical.push({ name: titleMap[value], value });\n      });\n    }\n    return canonical;\n  }\n  return titleMap;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/canonical-title-map.js","module.exports = require('./lib/ObjectPath.js').ObjectPath;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/objectpath/index.js\n// module id = 2\n// module chunks = 0","import { stringify } from './sf-path';\nimport canonicalTitleMap from './canonical-title-map';\n\n/* Utils */\nconst stripNullType = (type) => {\n  if (Array.isArray(type) && type.length === 2) {\n    if (type[0] === 'null') {\n      return type[1];\n    };\n    if (type[1] === 'null') {\n      return type[0];\n    };\n  };\n  return type;\n};\n\n// Creates an default titleMap list from an enum, i.e. a list of strings.\nconst enumToTitleMap = (enm) => {\n  const titleMap = []; // canonical titleMap format is a list.\n  enm.forEach((name) => {\n    titleMap.push({ name, value: name });\n  });\n  return titleMap;\n};\n\n/**\n * Creates a default form definition from a schema.\n */\nexport function defaultFormDefinition(schemaTypes, name, schema, options) {\n  const rules = schemaTypes[stripNullType(schema.type)];\n  if (rules) {\n    let def;\n    // We give each rule a possibility to recurse it's children.\n    const innerDefaultFormDefinition = (childName, childSchema , childOptions) =>\n                          defaultFormDefinition(schemaTypes, childName, childSchema, childOptions);\n    for (let i = 0; i < rules.length; i++) {\n      def = rules[i](name, schema, options, innerDefaultFormDefinition);\n\n      // first handler in list that actually returns something is our handler!\n      if (def) {\n\n        // Do we have form defaults in the schema under the x-schema-form-attribute?\n        if (def.schema['x-schema-form']) {\n          Object.assign(def, def.schema['x-schema-form']);\n        }\n\n        return def;\n      }\n    }\n  }\n}\n\n/**\n * Creates a form object with all common properties\n */\nexport function stdFormObj(name, schema, options) {\n  options = options || {};\n\n  // The Object.assign used to be a angular.copy. Should work though.\n  const f = options.global && options.global.formDefaults ?\n          Object.assign({}, options.global.formDefaults) : {};\n  if (options.global && options.global.supressPropertyTitles === true) {\n    f.title = schema.title;\n  }\n  else {\n    f.title = schema.title || name;\n  }\n\n  if (schema.description) { f.description = schema.description; }\n  if (options.required === true || schema.required === true) { f.required = true; }\n  if (schema.maxLength) { f.maxlength = schema.maxLength; }\n  if (schema.minLength) { f.minlength = schema.minLength; }\n  if (schema.readOnly || schema.readonly) { f.readonly  = true; }\n  if (schema.minimum) { f.minimum = schema.minimum + (schema.exclusiveMinimum ? 1 : 0); }\n  if (schema.maximum) { f.maximum = schema.maximum - (schema.exclusiveMaximum ? 1 : 0); }\n\n  // Non standard attributes (DONT USE DEPRECATED)\n  // If you must set stuff like this in the schema use the x-schema-form attribute\n  if (schema.validationMessage) { f.validationMessage = schema.validationMessage; }\n  if (schema.enumNames) { f.titleMap = canonicalTitleMap(schema.enumNames, schema['enum']); }\n  f.schema = schema;\n\n  if (schema.format) { f.format = schema.format; }\n\n  // Ng model options doesn't play nice with undefined, might be defined\n  // globally though\n  f.ngModelOptions = f.ngModelOptions || {};\n\n  return f;\n};\n\n/*** Schema types to form type mappings, with defaults ***/\nexport function text(name, schema, options) {\n  if (stripNullType(schema.type) === 'string' && !schema['enum']) {\n    const f = stdFormObj(name, schema, options);\n    f.key  = options.path;\n    f.type = 'text';\n    options.lookup[stringify(options.path)] = f;\n    return f;\n  }\n}\n\n// default in json form for number and integer is a text field\n// input type=\"number\" would be more suitable don't ya think?\nexport function number(name, schema, options) {\n  if (stripNullType(schema.type) === 'number') {\n    const f = stdFormObj(name, schema, options);\n    f.key  = options.path;\n    f.type = 'number';\n    options.lookup[stringify(options.path)] = f;\n    return f;\n  }\n}\n\nexport function integer(name, schema, options) {\n  if (stripNullType(schema.type) === 'integer') {\n    const f = stdFormObj(name, schema, options);\n    f.key  = options.path;\n    f.type = 'number';\n    options.lookup[stringify(options.path)] = f;\n    return f;\n  }\n}\n\nexport function checkbox(name, schema, options) {\n  if (stripNullType(schema.type) === 'boolean') {\n    const f = stdFormObj(name, schema, options);\n    f.key  = options.path;\n    f.type = 'checkbox';\n    options.lookup[stringify(options.path)] = f;\n    return f;\n  }\n}\n\nexport function select(name, schema, options) {\n  if (stripNullType(schema.type) === 'string' && schema['enum']) {\n    const f = stdFormObj(name, schema, options);\n    f.key  = options.path;\n    f.type = 'select';\n    if (!f.titleMap) {\n      f.titleMap = enumToTitleMap(schema['enum']);\n    }\n    options.lookup[stringify(options.path)] = f;\n    return f;\n  }\n}\n\nexport function geotypes(name, schema, options) {\n  if (stripNullType(schema.type) === 'string' && ['ogc-bbox', 'geojson-geometry', 'geojson-feature', 'geojson-feature-collection'].indexOf(schema.format) !== -1) {\n    const f = stdFormObj(name, schema, options);\n    f.key  = options.path;\n    f.type = schema.format.replace('ogc', '').replace('geojson', '').replace('-', '');\n    options.lookup[stringify(options.path)] = f;\n    console.log(f);\n    return f;\n  }\n}\n\nexport function checkboxes(name, schema, options) {\n  if (stripNullType(schema.type) === 'array' && schema.items && schema.items['enum']) {\n    const f = stdFormObj(name, schema, options);\n    f.key  = options.path;\n    f.type = 'checkboxes';\n    if (!f.titleMap) {\n      f.titleMap = enumToTitleMap(schema.items['enum']);\n    }\n    options.lookup[stringify(options.path)] = f;\n    return f;\n  }\n}\n\nexport function fieldset(name, schema, options, defaultFormDef) {\n  if (stripNullType(schema.type) === 'object') {\n    const f   = stdFormObj(name, schema, options);\n    f.type  = 'fieldset';\n    f.key   = options.path;\n    f.items = [];\n    options.lookup[stringify(options.path)] = f;\n\n    // recurse down into properties\n    if (schema.properties) {\n      Object.keys(schema.properties).forEach((key) => {\n        const value = schema.properties[key];\n        const path = options.path.slice();\n        path.push(key);\n        if (options.ignore[stringify(path)] !== true) {\n          const required = schema.required && schema.required.indexOf(key) !== -1;\n\n          const def = defaultFormDef(key, value, {\n            path,\n            required: required || false,\n            lookup: options.lookup,\n            ignore: options.ignore,\n            global: options.global\n          });\n          if (def) {\n            f.items.push(def);\n          }\n        }\n      });\n    }\n    return f;\n  }\n}\n\nexport function array(name, schema, options, defaultFormDef) {\n  if (stripNullType(schema.type) === 'array') {\n    const f   = stdFormObj(name, schema, options);\n    f.type  = 'array';\n    f.key   = options.path;\n    options.lookup[stringify(options.path)] = f;\n\n    const required = schema.required &&\n                   schema.required.indexOf(options.path[options.path.length - 1]) !== -1;\n\n    // The default is to always just create one child. This works since if the\n    // schemas items declaration is of type: \"object\" then we get a fieldset.\n    // We also follow json form notatation, adding empty brackets \"[]\" to\n    // signify arrays.\n\n    const arrPath = options.path.slice();\n    arrPath.push('');\n\n    f.items = [\n      defaultFormDef(name, schema.items, {\n        path: arrPath,\n        required: required || false,\n        lookup: options.lookup,\n        ignore: options.ignore,\n        global: options.global\n      })\n    ];\n\n    return f;\n  }\n}\n\nexport function createDefaults() {\n  // First sorted by schema type then a list.\n  // Order has importance. First handler returning an form snippet will be used.\n  return {\n    string:  [ geotypes, select, text ],\n    object:  [ fieldset ],\n    number:  [ number ],\n    integer: [ integer ],\n    boolean: [ checkbox ],\n    array:   [ checkboxes, array ]\n  };\n};\n\n/**\n * Create form defaults from schema\n */\nexport function defaultForm(schema: any, defaultSchemaTypes: any, ignore?: any, globalOptions?: any) {\n  const form   = [];\n  const lookup = {}; // Map path => form obj for fast lookup in merging\n  ignore = ignore || {};\n  globalOptions = globalOptions || {};\n  defaultSchemaTypes = defaultSchemaTypes || createDefaults();\n\n  if (schema.properties) {\n    Object.keys(schema.properties).forEach((key) => {\n      if (ignore[key] !== true) {\n        const required = schema.required && schema.required.indexOf(key) !== -1;\n        const def = defaultFormDefinition(defaultSchemaTypes, key, schema.properties[key], {\n          path: [ key ],         // Path to this property in bracket notation.\n          lookup: lookup,    // Extra map to register with. Optimization for merger.\n          ignore: ignore,    // The ignore list of paths (sans root level name)\n          required: required, // Is it required? (v4 json schema style)\n          global: globalOptions // Global options, including form defaults\n        });\n        if (def) {\n          form.push(def);\n        }\n      }\n    });\n  }\n  else {\n    throw new Error('Not implemented. Only type \"object\" allowed at root level of schema.');\n  }\n  return { form: form, lookup: lookup };\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/schema-defaults.js","import * as schemaDefaultsImp from './lib/schema-defaults';\nimport * as sfPathImp from './lib/sf-path';\nimport canonicalTitleMapImp from './lib/canonical-title-map';\n\nexport { merge } from './lib/merge';\nexport { select }  from './lib/select';\nexport { jsonref }  from './lib/resolve';\nexport { traverseSchema, traverseForm } from './lib/traverse';\nexport { validate } from './lib/validate';\n\nexport const sfPath = sfPathImp;\nexport const schemaDefaults = schemaDefaultsImp;\nexport const canonicalTitleMap = canonicalTitleMapImp;\n\n\n\n// WEBPACK FOOTER //\n// ./src/module.js","(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})\n\n\n// WEBPACK FOOTER //\n// node_modules/browser-pack/_prelude.js","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2014 Jeremy Whitlock\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n/**\n * Various utilities for JSON References *(http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)* and\n * JSON Pointers *(https://tools.ietf.org/html/rfc6901)*.\n *\n * @module JsonRefs\n */\n\nvar path = require('path');\nvar PathLoader = require('path-loader');\nvar qs = require('querystring');\nvar slash = require('slash');\nvar URI = require('uri-js');\n\nvar badPtrTokenRegex = /~(?:[^01]|$)/g;\nvar remoteCache = {};\nvar remoteTypes = ['relative', 'remote'];\nvar remoteUriTypes = ['absolute', 'uri'];\nvar uriDetailsCache = {};\n\n// Load promises polyfill if necessary\n/* istanbul ignore if */\nif (typeof Promise === 'undefined') {\n  require('native-promise-only');\n}\n\n/* Internal Functions */\n\n// This is a very simplistic clone function that does not take into account non-JSON types.  For these types the\n// original value is used as the clone.  So while it's not a complete deep clone, for the needs of this project\n// this should be sufficient.\nfunction clone (obj) {\n  var cloned;\n\n  if (isType(obj, 'Array')) {\n    cloned = [];\n\n    obj.forEach(function (value, index) {\n      cloned[index] = clone(value);\n    });\n  } else if (isType(obj, 'Object')) {\n    cloned = {};\n\n    Object.keys(obj).forEach(function (key) {\n      cloned[key] = clone(obj[key]);\n    });\n  } else {\n    cloned = obj;\n  }\n\n  return cloned;\n}\n\nfunction combineQueryParams (qs1, qs2) {\n  var combined = {};\n\n  function mergeQueryParams (obj) {\n    Object.keys(obj).forEach(function (key) {\n      combined[key] = obj[key];\n    });\n  }\n\n  mergeQueryParams(qs.parse(qs1 || ''));\n  mergeQueryParams(qs.parse(qs2 || ''));\n\n  return Object.keys(combined).length === 0 ? undefined : qs.stringify(combined);\n}\n\nfunction combineURIs (u1, u2) {\n  // Convert Windows paths\n  if (isType(u1, 'String')) {\n    u1 = slash(u1);\n  }\n\n  if (isType(u2, 'String')) {\n    u2 = slash(u2);\n  }\n\n  var u2Details = parseURI(isType(u2, 'Undefined') ? '' : u2);\n  var u1Details;\n  var combinedDetails;\n\n  if (remoteUriTypes.indexOf(u2Details.reference) > -1) {\n    combinedDetails = u2Details;\n  } else {\n    u1Details = isType(u1, 'Undefined') ? undefined : parseURI(u1);\n\n    if (!isType(u1Details, 'Undefined')) {\n      combinedDetails = u1Details;\n\n      // Join the paths\n      combinedDetails.path = slash(path.join(u1Details.path, u2Details.path));\n\n      // Join query parameters\n      combinedDetails.query = combineQueryParams(u1Details.query, u2Details.query);\n    } else {\n      combinedDetails = u2Details;\n    }\n  }\n\n  // Remove the fragment\n  combinedDetails.fragment = undefined;\n\n  // For relative URIs, add back the '..' since it was removed above\n  return (remoteUriTypes.indexOf(combinedDetails.reference) === -1 &&\n          combinedDetails.path.indexOf('../') === 0 ? '../' : '') + URI.serialize(combinedDetails);\n}\n\nfunction findAncestors (obj, path) {\n  var ancestors = [];\n  var node;\n\n  if (path.length > 0) {\n    node = obj;\n\n    path.slice(0, path.length - 1).forEach(function (seg) {\n      if (seg in node) {\n        node = node[seg];\n\n        ancestors.push(node);\n      }\n    });\n  }\n\n  return ancestors;\n}\n\nfunction processSubDocument (mode, doc, subDocPath, refDetails, options, parents, parentPtrs, allRefs, indirect) {\n  var refValue;\n  var rOptions;\n\n  if (subDocPath.length > 0) {\n    try {\n      refValue = findValue(doc, subDocPath);\n    } catch (err) {\n      // We only mark missing remote references as missing because local references can have deferred values\n      if (mode === 'remote') {\n        refDetails.error = err.message;\n        refDetails.missing = true;\n      }\n    }\n  } else {\n    refValue = doc;\n  }\n\n  if (!isType(refValue, 'Undefined')) {\n    refDetails.value = refValue;\n  }\n\n  if (isType(refValue, 'Array') || isType(refValue, 'Object')) {\n    rOptions = clone(options);\n\n    if (mode === 'local') {\n      delete rOptions.subDocPath;\n\n      // Traverse the dereferenced value\n      doc = refValue;\n    } else {\n      rOptions.relativeBase = path.dirname(parents[parents.length - 1]);\n\n      if (subDocPath.length === 0) {\n        delete rOptions.subDocPath;\n      } else {\n        rOptions.subDocPath = subDocPath;\n      }\n    }\n\n    return findRefsRecursive(doc, rOptions, parents, parentPtrs, allRefs, indirect);\n  }\n}\n\n// Should this be its own exported API?\nfunction findRefsRecursive (obj, options, parents, parentPtrs, allRefs, indirect) {\n  var allTasks = Promise.resolve();\n  var parentPath = parentPtrs.length ? pathFromPtr(parentPtrs[parentPtrs.length - 1]) : [];\n  var refs = findRefs(obj, options);\n  var subDocPath = options.subDocPath || [];\n  var subDocPtr = pathToPtr(subDocPath);\n  var ancestorPtrs = ['#'];\n\n  parents.forEach(function (parent, index) {\n    if (parent.charAt(0) !== '#') {\n      ancestorPtrs.push(parentPtrs[index]);\n    }\n  });\n\n  // Reverse the order so we search them in the proper order\n  ancestorPtrs.reverse();\n\n  if ((parents[parents.length - 1] || '').charAt(0) !== '#') {\n    allRefs.documents[pathToPtr(parentPath)] = obj;\n  }\n\n  Object.keys(refs).forEach(function (refPtr) {\n    var refDetails = refs[refPtr];\n    var location;\n    var parentIndex;\n    var refFullPath;\n    var refFullPtr;\n\n    // If there are no parents, treat the reference pointer as-is.  Otherwise, the reference is a reference within a\n    // remote document and its sub document path prefix must be removed.\n    if (parents.length === 0) {\n      refFullPath = parentPath.concat(pathFromPtr(refPtr));\n    } else {\n      refFullPath = parentPath.concat(pathFromPtr(refPtr).slice(parents.length === 0 ? 0 : subDocPath.length));\n    }\n\n    refFullPtr = pathToPtr(refFullPath);\n\n    // It is possible to process the same reference more than once in the event of hierarchical references so we avoid\n    // processing a reference if we've already done so.\n    if (!isType(allRefs[refFullPtr], 'Undefined')) {\n      return;\n    }\n\n    // Record the reference metadata\n    allRefs.refs[refFullPtr] = refs[refPtr];\n\n    // Do not process invalid references\n    if (isType(refDetails.error, 'Undefined') && refDetails.type !== 'invalid') {\n      if (remoteTypes.indexOf(refDetails.type) > -1) {\n        location = combineURIs(options.relativeBase, refDetails.uri);\n        parentIndex = parents.indexOf(location);\n      } else {\n        location = refDetails.uri;\n        parentIndex = parentPtrs.indexOf(location);\n      }\n\n      // Record ancestor paths\n      refDetails.ancestorPtrs = ancestorPtrs;\n\n      // Record if the reference is indirect based on its parent\n      refDetails.indirect = indirect;\n\n      // Only process non-circular references further\n      if (parentIndex === -1) {\n        if (remoteTypes.indexOf(refDetails.type) > -1) {\n          allTasks = allTasks\n            .then(function () {\n              return getRemoteDocument(location, options)\n                .then(function (doc) {\n                  return processSubDocument('remote',\n                                            doc,\n                                            isType(refDetails.uriDetails.fragment, 'Undefined') ?\n                                              [] :\n                                              pathFromPtr(decodeURI(refDetails.uriDetails.fragment)),\n                                            refDetails,\n                                            options,\n                                            parents.concat(location),\n                                            parentPtrs.concat(refFullPtr),\n                                            allRefs,\n                                            indirect);\n                })\n                .catch(function (err) {\n                  refDetails.error = err.message;\n                  refDetails.missing = true;\n                });\n            });\n        } else {\n          if (refFullPtr.indexOf(location + '/') !== 0 && refFullPtr !== location &&\n              subDocPtr.indexOf(location + '/') !== 0 && subDocPtr !== location) {\n            if (location.indexOf(subDocPtr + '/') !== 0) {\n              allTasks = allTasks\n                .then(function () {\n                  return processSubDocument('local',\n                                            obj,\n                                            pathFromPtr(location),\n                                            refDetails,\n                                            options,\n                                            parents.concat(location),\n                                            parentPtrs.concat(refFullPtr),\n                                            allRefs,\n                                            indirect || (location.indexOf(subDocPtr + '/') === -1 && location !== subDocPtr));\n                });\n            }\n          } else {\n            refDetails.circular = true;\n          }\n        }\n      } else {\n        // Mark seen ancestors as circular\n        parentPtrs.slice(parentIndex).forEach(function (parentPtr) {\n          allRefs.refs[parentPtr].circular = true;\n        });\n\n        refDetails.circular = true;\n      }\n    }\n  });\n\n  allTasks = allTasks\n    .then(function () {\n      // Identify indirect, local circular references (Issue 82)\n      var circulars = [];\n      var processedRefPtrs = [];\n      var processedRefs = [];\n\n      function walkRefs (parentPtrs, parentRefs, refPtr, ref) {\n        Object.keys(allRefs.refs).forEach(function (dRefPtr) {\n          var dRefDetails = allRefs.refs[dRefPtr];\n\n          // Do not process already processed references or references that are not a nested references\n          if (processedRefs.indexOf(ref) === -1 && processedRefPtrs.indexOf(refPtr) === -1 &&\n              circulars.indexOf(ref) === -1 && dRefPtr !== refPtr && dRefPtr.indexOf(ref + '/') === 0) {\n            if (parentRefs.indexOf(ref) > -1) {\n              parentRefs.forEach(function (parentRef) {\n                if (circulars.indexOf(ref) === -1) {\n                  circulars.push(parentRef);\n                }\n              });\n            } else {\n              walkRefs(parentPtrs.concat(refPtr), parentRefs.concat(ref), dRefPtr, dRefDetails.uri);\n            }\n\n            processedRefPtrs.push(refPtr);\n            processedRefs.push(ref);\n          }\n        });\n      }\n\n      Object.keys(allRefs.refs).forEach(function (refPtr) {\n        var refDetails = allRefs.refs[refPtr];\n\n        // Only process local, non-circular references\n        if (refDetails.type === 'local' && !refDetails.circular && circulars.indexOf(refDetails.uri) === -1) {\n          walkRefs([], [], refPtr, refDetails.uri);\n        }\n      });\n\n      Object.keys(allRefs.refs).forEach(function (refPtr) {\n        var refDetails = allRefs.refs[refPtr];\n\n        if (circulars.indexOf(refDetails.uri) > -1) {\n          refDetails.circular = true;\n        }\n      });\n    })\n    .then(function () {\n      return allRefs;\n    });\n\n  return allTasks;\n}\n\nfunction findValue (obj, path) {\n  var value = obj;\n\n  path.forEach(function (seg) {\n    seg = decodeURI(seg);\n\n    if (seg in value) {\n      value = value[seg];\n    } else {\n      throw Error('JSON Pointer points to missing location: ' + pathToPtr(path));\n    }\n  });\n\n  return value;\n}\n\nfunction getExtraRefKeys (ref) {\n  return Object.keys(ref).filter(function (key) {\n    return key !== '$ref';\n  });\n}\n\nfunction getRefType (refDetails) {\n  var type;\n\n  // Convert the URI reference to one of our types\n  switch (refDetails.uriDetails.reference) {\n  case 'absolute':\n  case 'uri':\n    type = 'remote';\n    break;\n  case 'same-document':\n    type = 'local';\n    break;\n  default:\n    type = refDetails.uriDetails.reference;\n  }\n\n  return type;\n}\n\nfunction getRemoteDocument (url, options) {\n  var cacheEntry = remoteCache[url];\n  var allTasks = Promise.resolve();\n  var loaderOptions = clone(options.loaderOptions || {});\n\n  if (isType(cacheEntry, 'Undefined')) {\n    // If there is no content processor, default to processing the raw response as JSON\n    if (isType(loaderOptions.processContent, 'Undefined')) {\n      loaderOptions.processContent = function (res, callback) {\n        callback(undefined, JSON.parse(res.text));\n      };\n    }\n\n    // Attempt to load the resource using path-loader\n    allTasks = PathLoader.load(decodeURI(url), loaderOptions);\n\n    // Update the cache\n    allTasks = allTasks\n      .then(function (res) {\n        remoteCache[url] = {\n          value: res\n        };\n\n        return res;\n      })\n      .catch(function (err) {\n        remoteCache[url] = {\n          error: err\n        };\n\n        throw err;\n      });\n  } else {\n    // Return the cached version\n    allTasks = allTasks.then(function () {\n      return cacheEntry.value;\n    });\n  }\n\n  // Return a cloned version to avoid updating the cache\n  allTasks = allTasks.then(function (res) {\n    return clone(res);\n  });\n\n  return allTasks;\n}\n\nfunction isRefLike (obj, throwWithDetails) {\n  var refLike = true;\n\n  try {\n    if (!isType(obj, 'Object')) {\n      throw new Error('obj is not an Object');\n    } else if (!isType(obj.$ref, 'String')) {\n      throw new Error('obj.$ref is not a String');\n    }\n  } catch (err) {\n    if (throwWithDetails) {\n      throw err;\n    }\n\n    refLike = false;\n  }\n\n  return refLike;\n}\n\nfunction isType (obj, type) {\n  // A PhantomJS bug (https://github.com/ariya/phantomjs/issues/11722) prohibits us from using the same approach for\n  // undefined checking that we use for other types.\n  if (type === 'Undefined') {\n    return typeof obj === 'undefined';\n  } else {\n    return Object.prototype.toString.call(obj) === '[object ' + type + ']';\n  }\n}\n\nfunction makeRefFilter (options) {\n  var refFilter;\n  var validTypes;\n\n  if (isType(options.filter, 'Array') || isType(options.filter, 'String')) {\n    validTypes = isType(options.filter, 'String') ? [options.filter] : options.filter;\n    refFilter = function (refDetails) {\n      // Check the exact type or for invalid URIs, check its original type\n      return validTypes.indexOf(refDetails.type) > -1 || validTypes.indexOf(getRefType(refDetails)) > -1;\n    };\n  } else if (isType(options.filter, 'Function')) {\n    refFilter = options.filter;\n  } else if (isType(options.filter, 'Undefined')) {\n    refFilter = function () {\n      return true;\n    };\n  }\n\n  return function (refDetails, path) {\n    return (refDetails.type !== 'invalid' || options.includeInvalid === true) && refFilter(refDetails, path);\n  };\n}\n\nfunction makeSubDocPath (options) {\n  var subDocPath;\n\n  if (isType(options.subDocPath, 'Array')) {\n    subDocPath = options.subDocPath;\n  } else if (isType(options.subDocPath, 'String')) {\n    subDocPath = pathFromPtr(options.subDocPath);\n  } else if (isType(options.subDocPath, 'Undefined')) {\n    subDocPath = [];\n  }\n\n  return subDocPath;\n}\n\nfunction parseURI (uri) {\n  // We decode first to avoid doubly encoding\n  return URI.parse(encodeURI(decodeURI(uri)));\n}\n\nfunction setValue (obj, refPath, value) {\n  findValue(obj, refPath.slice(0, refPath.length - 1))[decodeURI(refPath[refPath.length - 1])] = value;\n}\n\nfunction walk (ancestors, node, path, fn) {\n  var processChildren = true;\n\n  function walkItem (item, segment) {\n    path.push(segment);\n    walk(ancestors, item, path, fn);\n    path.pop();\n  }\n\n  // Call the iteratee\n  if (isType(fn, 'Function')) {\n    processChildren = fn(ancestors, node, path);\n  }\n\n  // We do not process circular objects again\n  if (ancestors.indexOf(node) === -1) {\n    ancestors.push(node);\n\n    if (processChildren !== false) {\n      if (isType(node, 'Array')) {\n        node.forEach(function (member, index) {\n          walkItem(member, index.toString());\n        });\n      } else if (isType(node, 'Object')) {\n        Object.keys(node).forEach(function (key) {\n          walkItem(node[key], key);\n        });\n      }\n    }\n  }\n\n  ancestors.pop();\n}\n\nfunction validateOptions (options, obj) {\n  if (isType(options, 'Undefined')) {\n    // Default to an empty options object\n    options = {};\n  } else {\n    // Clone the options so we do not alter the ones passed in\n    options = clone(options);\n  }\n\n  if (!isType(options, 'Object')) {\n    throw new TypeError('options must be an Object');\n  } else if (!isType(options.filter, 'Undefined') &&\n             !isType(options.filter, 'Array') &&\n             !isType(options.filter, 'Function') &&\n             !isType(options.filter, 'String')) {\n    throw new TypeError('options.filter must be an Array, a Function of a String');\n  } else if (!isType(options.includeInvalid, 'Undefined') &&\n             !isType(options.includeInvalid, 'Boolean')) {\n    throw new TypeError('options.includeInvalid must be a Boolean');\n  } else if (!isType(options.refPreProcessor, 'Undefined') &&\n             !isType(options.refPreProcessor, 'Function')) {\n    throw new TypeError('options.refPreProcessor must be a Function');\n  } else if (!isType(options.refPostProcessor, 'Undefined') &&\n             !isType(options.refPostProcessor, 'Function')) {\n    throw new TypeError('options.refPostProcessor must be a Function');\n  } else if (!isType(options.subDocPath, 'Undefined') &&\n             !isType(options.subDocPath, 'Array') &&\n             !isPtr(options.subDocPath)) {\n    // If a pointer is provided, throw an error if it's not the proper type\n    throw new TypeError('options.subDocPath must be an Array of path segments or a valid JSON Pointer');\n  }\n\n  options.filter = makeRefFilter(options);\n\n  // Set the subDocPath to avoid everyone else having to compute it\n  options.subDocPath = makeSubDocPath(options);\n\n  if (!isType(obj, 'Undefined')) {\n    try {\n      findValue(obj, options.subDocPath);\n    } catch (err) {\n      err.message = err.message.replace('JSON Pointer', 'options.subDocPath');\n\n      throw err;\n    }\n  }\n\n  return options;\n}\n\n/* Module Members */\n\n/*\n * Each of the functions below are defined as function statements and *then* exported in two steps instead of one due\n * to a bug in jsdoc (https://github.com/jsdoc2md/jsdoc-parse/issues/18) that causes our documentation to be\n * generated improperly.  The impact to the user is significant enough for us to warrant working around it until this\n * is fixed.\n */\n\n/**\n * The options used for various JsonRefs APIs.\n *\n * @typedef {object} JsonRefsOptions\n *\n * @param {string|string[]|function} [filter=function () {return true;}] - The filter to use when gathering JSON\n * References *(If this value is a single string or an array of strings, the value(s) are expected to be the `type(s)`\n * you are interested in collecting as described in {@link module:JsonRefs.getRefDetails}.  If it is a function, it is\n * expected that the function behaves like {@link module:JsonRefs~RefDetailsFilter}.)*\n * @param {boolean} [includeInvalid=false] - Whether or not to include invalid JSON Reference details *(This will make\n * it so that objects that are like JSON Reference objects, as in they are an `Object` and the have a `$ref` property,\n * but fail validation will be included.  This is very useful for when you want to know if you have invalid JSON\n * Reference definitions.  This will not mean that APIs will process invalid JSON References but the reasons as to why\n * the JSON References are invalid will be included in the returned metadata.)*\n * @param {object} [loaderOptions] - The options to pass to\n * {@link https://github.com/whitlockjc/path-loader/blob/master/docs/API.md#module_PathLoader.load|PathLoader~load}\n * @param {module:JsonRefs~RefPreProcessor} [refPreProcessor] - The callback used to pre-process a JSON Reference like\n * object *(This is called prior to validating the JSON Reference like object and getting its details)*\n * @param {module:JsonRefs~RefPostProcessor} [refPostProcessor] - The callback used to post-process the JSON Reference\n * metadata *(This is called prior filtering the references)*\n * @param {string} [options.relativeBase] - The base location to use when resolving relative references *(Only useful\n * for APIs that do remote reference resolution.  If this value is not defined,\n * {@link https://github.com/whitlockjc/path-loader|path-loader} will use `window.location.href` for the browser and\n * `process.cwd()` for Node.js.)*\n * @param {string|string[]} [options.subDocPath=[]] - The JSON Pointer or array of path segments to the sub document\n * location to search from\n */\n\n/**\n * Simple function used to filter out JSON References.\n *\n * @typedef {function} RefDetailsFilter\n *\n * @param {module:JsonRefs~UnresolvedRefDetails} refDetails - The JSON Reference details to test\n * @param {string[]} path - The path to the JSON Reference\n *\n * @returns {boolean} whether the JSON Reference should be filtered *(out)* or not\n */\n\n/**\n * Simple function used to pre-process a JSON Reference like object.\n *\n * @typedef {function} RefPreProcessor\n *\n * @param {object} obj - The JSON Reference like object\n * @param {string[]} path - The path to the JSON Reference like object\n *\n * @returns {object} the processed JSON Reference like object\n */\n\n/**\n * Simple function used to post-process a JSON Reference details.\n *\n * @typedef {function} RefPostProcessor\n *\n * @param {module:JsonRefs~UnresolvedRefDetails} refDetails - The JSON Reference details to test\n * @param {string[]} path - The path to the JSON Reference\n *\n * @returns {object} the processed JSON Reference details object\n */\n\n/**\n * Detailed information about resolved JSON References.\n *\n * @typedef {module:JsonRefs~UnresolvedRefDetails} ResolvedRefDetails\n *\n * @property {boolean} [circular] - Whether or not the JSON Reference is circular *(Will not be set if the JSON\n * Reference is not circular)*\n * @property {boolean} [missing] - Whether or not the referenced value was missing or not *(Will not be set if the\n * referenced value is not missing)*\n * @property {*} [value] - The referenced value *(Will not be set if the referenced value is missing)*\n */\n\n/**\n * The results of resolving the JSON References of an array/object.\n *\n * @typedef {object} ResolvedRefsResults\n *\n * @property {module:JsonRefs~ResolvedRefDetails} refs - An object whose keys are JSON Pointers *(fragment version)*\n * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~ResolvedRefDetails}\n * @property {object} resolved - The array/object with its JSON References fully resolved\n */\n\n/**\n * An object containing the retrieved document and detailed information about its JSON References.\n *\n * @typedef {module:JsonRefs~ResolvedRefsResults} RetrievedRefsResults\n *\n * @property {object} value - The retrieved document\n */\n\n/**\n * An object containing the retrieved document, the document with its references resolved and  detailed information\n * about its JSON References.\n *\n * @typedef {object} RetrievedResolvedRefsResults\n *\n * @property {module:JsonRefs~UnresolvedRefDetails} refs - An object whose keys are JSON Pointers *(fragment version)*\n * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~UnresolvedRefDetails}\n * @property {ResolvedRefsResults} - An object whose keys are JSON Pointers *(fragment version)*\n * to where the JSON Reference is defined and whose values are {@link module:JsonRefs~ResolvedRefDetails}\n * @property {object} value - The retrieved document\n */\n\n/**\n * Detailed information about unresolved JSON References.\n *\n * @typedef {object} UnresolvedRefDetails\n *\n * @property {object} def - The JSON Reference definition\n * @property {string} [error] - The error information for invalid JSON Reference definition *(Only present when the\n * JSON Reference definition is invalid or there was a problem retrieving a remote reference during resolution)*\n * @property {string} uri - The URI portion of the JSON Reference\n * @property {object} uriDetails - Detailed information about the URI as provided by\n * {@link https://github.com/garycourt/uri-js|URI.parse}.\n * @property {string} type - The JSON Reference type *(This value can be one of the following: `invalid`, `local`,\n * `relative` or `remote`.)*\n * @property {string} [warning] - The warning information *(Only present when the JSON Reference definition produces a\n * warning)*\n */\n\n/**\n * Clears the internal cache of remote documents, reference details, etc.\n *\n * @alias module:JsonRefs.clearCache\n */\nfunction clearCache () {\n  remoteCache = {};\n}\n\n/**\n * Takes an array of path segments and decodes the JSON Pointer tokens in them.\n *\n * @param {string[]} path - The array of path segments\n *\n * @returns {string} the array of path segments with their JSON Pointer tokens decoded\n *\n * @throws {Error} if the path is not an `Array`\n *\n * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @alias module:JsonRefs.decodePath\n */\nfunction decodePath (path) {\n  if (!isType(path, 'Array')) {\n    throw new TypeError('path must be an array');\n  }\n\n  return path.map(function (seg) {\n    if (!isType(seg, 'String')) {\n      seg = JSON.stringify(seg);\n    }\n\n    return decodeURI(seg.replace(/~1/g, '/').replace(/~0/g, '~'));\n  });\n}\n\n/**\n * Takes an array of path segments and encodes the special JSON Pointer characters in them.\n *\n * @param {string[]} path - The array of path segments\n *\n * @returns {string} the array of path segments with their JSON Pointer tokens encoded\n *\n * @throws {Error} if the path is not an `Array`\n *\n * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @alias module:JsonRefs.encodePath\n */\nfunction encodePath (path) {\n  if (!isType(path, 'Array')) {\n    throw new TypeError('path must be an array');\n  }\n\n  return path.map(function (seg) {\n    if (!isType(seg, 'String')) {\n      seg = JSON.stringify(seg);\n    }\n\n    return seg.replace(/~/g, '~0').replace(/\\//g, '~1');\n  });\n}\n\n/**\n * Finds JSON References defined within the provided array/object.\n *\n * @param {array|object} obj - The structure to find JSON References within\n * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n *\n * @returns {object} an object whose keys are JSON Pointers *(fragment version)* to where the JSON Reference is defined\n * and whose values are {@link module:JsonRefs~UnresolvedRefDetails}.\n *\n * @throws {Error} when the input arguments fail validation or if `options.subDocPath` points to an invalid location\n *\n * @alias module:JsonRefs.findRefs\n *\n * @example\n * // Finding all valid references\n * var allRefs = JsonRefs.findRefs(obj);\n * // Finding all remote references\n * var remoteRefs = JsonRefs.findRefs(obj, {filter: ['relative', 'remote']});\n * // Finding all invalid references\n * var invalidRefs = JsonRefs.findRefs(obj, {filter: 'invalid', includeInvalid: true});\n */\nfunction findRefs (obj, options) {\n  var refs = {};\n\n  // Validate the provided document\n  if (!isType(obj, 'Array') && !isType(obj, 'Object')) {\n    throw new TypeError('obj must be an Array or an Object');\n  }\n\n  // Validate options\n  options = validateOptions(options, obj);\n\n  // Walk the document (or sub document) and find all JSON References\n  walk(findAncestors(obj, options.subDocPath),\n       findValue(obj, options.subDocPath),\n       clone(options.subDocPath),\n       function (ancestors, node, path) {\n         var processChildren = true;\n         var refDetails;\n\n         if (isRefLike(node)) {\n           // Pre-process the node when necessary\n           if (!isType(options.refPreProcessor, 'Undefined')) {\n             node = options.refPreProcessor(clone(node), path);\n           }\n\n           refDetails = getRefDetails(node);\n\n           // Post-process the reference details\n           if (!isType(options.refPostProcessor, 'Undefined')) {\n             refDetails = options.refPostProcessor(refDetails, path);\n           }\n\n           if (options.filter(refDetails, path)) {\n             refs[pathToPtr(path)] = refDetails;\n           }\n\n           // Whenever a JSON Reference has extra children, its children should not be processed.\n           //   See: http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3\n           if (getExtraRefKeys(node).length > 0) {\n             processChildren = false;\n           }\n         }\n\n         return processChildren;\n       });\n\n  return refs;\n}\n\n/**\n * Finds JSON References defined within the document at the provided location.\n *\n * This API is identical to {@link module:JsonRefs.findRefs} except this API will retrieve a remote document and then\n * return the result of {@link module:JsonRefs.findRefs} on the retrieved document.\n *\n * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the\n * {@link module:JsonRefs~JsonRefsOptions|options documentation} to see how relative references are handled.)*\n * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n *\n * @returns {Promise} a promise that resolves a {@link module:JsonRefs~RetrievedRefsResults} and rejects with an\n * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n *  the location argument points to an unloadable resource\n *\n * @alias module:JsonRefs.findRefsAt\n *\n * @example\n * // Example that only resolves references within a sub document\n * JsonRefs.findRefsAt('http://petstore.swagger.io/v2/swagger.json', {\n *     subDocPath: '#/definitions'\n *   })\n *   .then(function (res) {\n *      // Do something with the response\n *      //\n *      // res.refs: JSON Reference locations and details\n *      // res.value: The retrieved document\n *   }, function (err) {\n *     console.log(err.stack);\n *   });\n */\nfunction findRefsAt (location, options) {\n  var allTasks = Promise.resolve();\n\n  allTasks = allTasks\n    .then(function () {\n      // Validate the provided location\n      if (!isType(location, 'String')) {\n        throw new TypeError('location must be a string');\n      }\n\n      // Validate options\n      options = validateOptions(options);\n\n      // Combine the location and the optional relative base\n      location = combineURIs(options.relativeBase, location);\n\n      return getRemoteDocument(location, options);\n    })\n    .then(function (res) {\n      var cacheEntry = clone(remoteCache[location]);\n      var cOptions = clone(options);\n      var uriDetails = parseURI(location);\n\n      if (isType(cacheEntry.refs, 'Undefined')) {\n        // Do not filter any references so the cache is complete\n        delete cOptions.filter;\n        delete cOptions.subDocPath;\n\n        cOptions.includeInvalid = true;\n\n        remoteCache[location].refs = findRefs(res, cOptions);\n      }\n\n      // Add the filter options back\n      if (!isType(options.filter, 'Undefined')) {\n        cOptions.filter = options.filter;\n      }\n\n      if (!isType(uriDetails.fragment, 'Undefined')) {\n        cOptions.subDocPath = pathFromPtr(decodeURI(uriDetails.fragment));\n      } else if (!isType(uriDetails.subDocPath, 'Undefined')) {\n        cOptions.subDocPath = options.subDocPath;\n      }\n\n      // This will use the cache so don't worry about calling it twice\n      return {\n        refs: findRefs(res, cOptions),\n        value: res\n      };\n    });\n\n  return allTasks;\n}\n\n/**\n * Returns detailed information about the JSON Reference.\n *\n * @param {object} obj - The JSON Reference definition\n *\n * @returns {module:JsonRefs~UnresolvedRefDetails} the detailed information\n *\n * @alias module:JsonRefs.getRefDetails\n */\nfunction getRefDetails (obj) {\n  var details = {\n    def: obj\n  };\n  var cacheKey;\n  var extraKeys;\n  var uriDetails;\n\n  try {\n    if (isRefLike(obj, true)) {\n      cacheKey = obj.$ref;\n      uriDetails = uriDetailsCache[cacheKey];\n\n      if (isType(uriDetails, 'Undefined')) {\n        uriDetails = uriDetailsCache[cacheKey] = parseURI(cacheKey);\n      }\n\n      details.uri = cacheKey;\n      details.uriDetails = uriDetails;\n\n      if (isType(uriDetails.error, 'Undefined')) {\n        details.type = getRefType(details);\n      } else {\n        details.error = details.uriDetails.error;\n        details.type = 'invalid';\n      }\n\n      // Identify warning\n      extraKeys = getExtraRefKeys(obj);\n\n      if (extraKeys.length > 0) {\n        details.warning = 'Extra JSON Reference properties will be ignored: ' + extraKeys.join(', ');\n      }\n    } else {\n      details.type = 'invalid';\n    }\n  } catch (err) {\n    details.error = err.message;\n    details.type = 'invalid';\n  }\n\n  return details;\n}\n\n/**\n * Returns whether the argument represents a JSON Pointer.\n *\n * A string is a JSON Pointer if the following are all true:\n *\n *   * The string is of type `String`\n *   * The string must be empty, `#` or start with a `/` or `#/`\n *\n * @param {string} ptr - The string to check\n * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value\n * provided is invalid\n *\n * @returns {boolean} the result of the check\n *\n * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`\n *\n * @alias module:JsonRefs.isPtr\n *\n * @see {@link https://tools.ietf.org/html/rfc6901#section-3}\n *\n * @example\n * // Separating the different ways to invoke isPtr for demonstration purposes\n * if (isPtr(str)) {\n *   // Handle a valid JSON Pointer\n * } else {\n *   // Get the reason as to why the value is not a JSON Pointer so you can fix/report it\n *   try {\n *     isPtr(str, true);\n *   } catch (err) {\n *     // The error message contains the details as to why the provided value is not a JSON Pointer\n *   }\n * }\n */\nfunction isPtr (ptr, throwWithDetails) {\n  var valid = true;\n  var firstChar;\n\n  try {\n    if (isType(ptr, 'String')) {\n      if (ptr !== '') {\n        firstChar = ptr.charAt(0);\n\n        if (['#', '/'].indexOf(firstChar) === -1) {\n          throw new Error('ptr must start with a / or #/');\n        } else if (firstChar === '#' && ptr !== '#' && ptr.charAt(1) !== '/') {\n          throw new Error('ptr must start with a / or #/');\n        } else if (ptr.match(badPtrTokenRegex)) {\n          throw new Error('ptr has invalid token(s)');\n        }\n      }\n    } else {\n      throw new Error('ptr is not a String');\n    }\n  } catch (err) {\n    if (throwWithDetails === true) {\n      throw err;\n    }\n\n    valid = false;\n  }\n\n  return valid;\n}\n\n/**\n * Returns whether the argument represents a JSON Reference.\n *\n * An object is a JSON Reference only if the following are all true:\n *\n *   * The object is of type `Object`\n *   * The object has a `$ref` property\n *   * The `$ref` property is a valid URI *(We do not require 100% strict URIs and will handle unescaped special\n *     characters.)*\n *\n * @param {object} obj - The object to check\n * @param {boolean} [throwWithDetails=false] - Whether or not to throw an `Error` with the details as to why the value\n * provided is invalid\n *\n * @returns {boolean} the result of the check\n *\n * @throws {error} when the provided value is invalid and the `throwWithDetails` argument is `true`\n *\n * @alias module:JsonRefs.isRef\n *\n * @see {@link http://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03#section-3}\n *\n * @example\n * // Separating the different ways to invoke isRef for demonstration purposes\n * if (isRef(obj)) {\n *   // Handle a valid JSON Reference\n * } else {\n *   // Get the reason as to why the value is not a JSON Reference so you can fix/report it\n *   try {\n *     isRef(str, true);\n *   } catch (err) {\n *     // The error message contains the details as to why the provided value is not a JSON Reference\n *   }\n * }\n */\nfunction isRef (obj, throwWithDetails) {\n  return isRefLike(obj, throwWithDetails) && getRefDetails(obj, throwWithDetails).type !== 'invalid';\n}\n\n/**\n * Returns an array of path segments for the provided JSON Pointer.\n *\n * @param {string} ptr - The JSON Pointer\n *\n * @returns {string[]} the path segments\n *\n * @throws {Error} if the provided `ptr` argument is not a JSON Pointer\n *\n * @alias module:JsonRefs.pathFromPtr\n */\nfunction pathFromPtr (ptr) {\n  if (!isPtr(ptr)) {\n    throw new Error('ptr must be a JSON Pointer');\n  }\n\n  var segments = ptr.split('/');\n\n  // Remove the first segment\n  segments.shift();\n\n  return decodePath(segments);\n}\n\n/**\n * Returns a JSON Pointer for the provided array of path segments.\n *\n * **Note:** If a path segment in `path` is not a `String`, it will be converted to one using `JSON.stringify`.\n *\n * @param {string[]} path - The array of path segments\n * @param {boolean} [hashPrefix=true] - Whether or not create a hash-prefixed JSON Pointer\n *\n * @returns {string} the corresponding JSON Pointer\n *\n * @throws {Error} if the `path` argument is not an array\n *\n * @alias module:JsonRefs.pathToPtr\n */\nfunction pathToPtr (path, hashPrefix) {\n  if (!isType(path, 'Array')) {\n    throw new Error('path must be an Array');\n  }\n\n  // Encode each segment and return\n  return (hashPrefix !== false ? '#' : '') + (path.length > 0 ? '/' : '') + encodePath(path).join('/');\n}\n\n/**\n * Finds JSON References defined within the provided array/object and resolves them.\n *\n * @param {array|object} obj - The structure to find JSON References within\n * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n *\n * @returns {Promise} a promise that resolves a {@link module:JsonRefs~ResolvedRefsResults} and rejects with an\n * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n *  the location argument points to an unloadable resource\n *\n * @alias module:JsonRefs.resolveRefs\n *\n * @example\n * // Example that only resolves relative and remote references\n * JsonRefs.resolveRefs(swaggerObj, {\n *     filter: ['relative', 'remote']\n *   })\n *   .then(function (res) {\n *      // Do something with the response\n *      //\n *      // res.refs: JSON Reference locations and details\n *      // res.resolved: The document with the appropriate JSON References resolved\n *   }, function (err) {\n *     console.log(err.stack);\n *   });\n */\nfunction resolveRefs (obj, options) {\n  var allTasks = Promise.resolve();\n\n  allTasks = allTasks\n    .then(function () {\n      // Validate the provided document\n      if (!isType(obj, 'Array') && !isType(obj, 'Object')) {\n        throw new TypeError('obj must be an Array or an Object');\n      }\n\n      // Validate options\n      options = validateOptions(options, obj);\n\n      // Clone the input so we do not alter it\n      obj = clone(obj);\n    })\n    .then(function () {\n      return findRefsRecursive(obj, options, [], [], {\n        documents: {},\n        refs: {}\n      });\n    })\n    .then(function (allRefs) {\n      var deferredRefs = {};\n      var refs = {};\n\n      function pathSorter (p1, p2) {\n        return pathFromPtr(p1).length - pathFromPtr(p2).length;\n      }\n\n      // Resolve all references with a known value\n      Object.keys(allRefs.refs).sort(pathSorter).forEach(function (refPtr) {\n        var refDetails = allRefs.refs[refPtr];\n\n        // Record all direct references\n        if (!refDetails.indirect) {\n          refs[refPtr] = refDetails;\n        }\n\n        // Delete helper property\n        delete refDetails.indirect;\n\n        if (isType(refDetails.error, 'Undefined') && refDetails.type !== 'invalid') {\n          if (isType(refDetails.value, 'Undefined') && refDetails.circular) {\n            refDetails.value = refDetails.def;\n          }\n\n          // We defer processing all references without a value until later\n          if (isType(refDetails.value, 'Undefined')) {\n            deferredRefs[refPtr] = refDetails;\n          } else {\n            if (refPtr === '#') {\n              obj = refDetails.value;\n            } else {\n              setValue(obj, pathFromPtr(refPtr), refDetails.value);\n            }\n\n            // Delete helper property\n            delete refDetails.ancestorPtrs;\n          }\n        } else {\n          // Delete helper property\n          delete refDetails.ancestorPtrs;\n        }\n      });\n\n      // Resolve all deferred references\n      Object.keys(deferredRefs).forEach(function (refPtr) {\n        var refDetails = deferredRefs[refPtr];\n\n        // Attempt to resolve the value against all if its ancestors in order\n        refDetails.ancestorPtrs.forEach(function (ancestorPtr, index) {\n          if (isType(refDetails.value, 'Undefined')) {\n            try {\n              refDetails.value = findValue(allRefs.documents[ancestorPtr], pathFromPtr(refDetails.uri));\n\n              // Delete helper property\n              delete refDetails.ancestorPtrs;\n\n              setValue(obj, pathFromPtr(refPtr), refDetails.value);\n            } catch (err) {\n              if (index === refDetails.ancestorPtrs.length - 1) {\n                refDetails.error = err.message;\n                refDetails.missing = true;\n\n                // Delete helper property\n                delete refDetails.ancestorPtrs;\n              }\n            }\n          }\n        });\n      });\n\n      return {\n        refs: refs,\n        resolved: obj\n      };\n    });\n\n  return allTasks;\n}\n\n/**\n * Resolves JSON References defined within the document at the provided location.\n *\n * This API is identical to {@link module:JsonRefs.resolveRefs} except this API will retrieve a remote document and then\n * return the result of {@link module:JsonRefs.resolveRefs} on the retrieved document.\n *\n * @param {string} location - The location to retrieve *(Can be relative or absolute, just make sure you look at the\n * {@link module:JsonRefs~JsonRefsOptions|options documentation} to see how relative references are handled.)*\n * @param {module:JsonRefs~JsonRefsOptions} [options] - The JsonRefs options\n *\n * @returns {Promise} a promise that resolves a {@link module:JsonRefs~RetrievedResolvedRefsResults} and rejects with an\n * `Error` when the input arguments fail validation, when `options.subDocPath` points to an invalid location or when\n *  the location argument points to an unloadable resource\n *\n * @alias module:JsonRefs.resolveRefsAt\n *\n * @example\n * // Example that loads a JSON document (No options.loaderOptions.processContent required) and resolves all references\n * JsonRefs.resolveRefsAt('./swagger.json')\n *   .then(function (res) {\n *      // Do something with the response\n *      //\n *      // res.refs: JSON Reference locations and details\n *      // res.resolved: The document with the appropriate JSON References resolved\n *      // res.value: The retrieved document\n *   }, function (err) {\n *     console.log(err.stack);\n *   });\n */\nfunction resolveRefsAt (location, options) {\n  var allTasks = Promise.resolve();\n\n  allTasks = allTasks\n    .then(function () {\n      // Validate the provided location\n      if (!isType(location, 'String')) {\n        throw new TypeError('location must be a string');\n      }\n\n      // Validate options\n      options = validateOptions(options);\n\n      // Combine the location and the optional relative base\n      location = combineURIs(options.relativeBase, location);\n\n      return getRemoteDocument(location, options);\n    })\n    .then(function (res) {\n      var cOptions = clone(options);\n      var uriDetails = parseURI(location);\n\n      // Set the sub document path if necessary\n      if (!isType(uriDetails.fragment, 'Undefined')) {\n        cOptions.subDocPath = pathFromPtr(decodeURI(uriDetails.fragment));\n      }\n\n      // Update the relative base based on the retrieved location\n      cOptions.relativeBase = path.dirname(location);\n\n      return resolveRefs(res, cOptions)\n        .then(function (res2) {\n          return {\n            refs: res2.refs,\n            resolved: res2.resolved,\n            value: res\n          };\n        });\n    });\n\n  return allTasks;\n}\n\n/* Export the module members */\nmodule.exports.clearCache = clearCache;\nmodule.exports.decodePath = decodePath;\nmodule.exports.encodePath = encodePath;\nmodule.exports.findRefs = findRefs;\nmodule.exports.findRefsAt = findRefsAt;\nmodule.exports.getRefDetails = getRefDetails;\nmodule.exports.isPtr = isPtr;\nmodule.exports.isRef = isRef;\nmodule.exports.pathFromPtr = pathFromPtr;\nmodule.exports.pathToPtr = pathToPtr;\nmodule.exports.resolveRefs = resolveRefs;\nmodule.exports.resolveRefsAt = resolveRefsAt;\n\n\n\n// WEBPACK FOOTER //\n// index.js","\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks['$' + event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/component-emitter/index.js","/*! Native Promise Only\n    v0.8.1 (c) Kyle Simpson\n    MIT License: http://getify.mit-license.org\n*/\n\n(function UMD(name,context,definition){\n\t// special form of UMD for polyfilling across evironments\n\tcontext[name] = context[name] || definition();\n\tif (typeof module != \"undefined\" && module.exports) { module.exports = context[name]; }\n\telse if (typeof define == \"function\" && define.amd) { define(function $AMD$(){ return context[name]; }); }\n})(\"Promise\",typeof global != \"undefined\" ? global : this,function DEF(){\n\t/*jshint validthis:true */\n\t\"use strict\";\n\n\tvar builtInProp, cycle, scheduling_queue,\n\t\tToString = Object.prototype.toString,\n\t\ttimer = (typeof setImmediate != \"undefined\") ?\n\t\t\tfunction timer(fn) { return setImmediate(fn); } :\n\t\t\tsetTimeout\n\t;\n\n\t// dammit, IE8.\n\ttry {\n\t\tObject.defineProperty({},\"x\",{});\n\t\tbuiltInProp = function builtInProp(obj,name,val,config) {\n\t\t\treturn Object.defineProperty(obj,name,{\n\t\t\t\tvalue: val,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: config !== false\n\t\t\t});\n\t\t};\n\t}\n\tcatch (err) {\n\t\tbuiltInProp = function builtInProp(obj,name,val) {\n\t\t\tobj[name] = val;\n\t\t\treturn obj;\n\t\t};\n\t}\n\n\t// Note: using a queue instead of array for efficiency\n\tscheduling_queue = (function Queue() {\n\t\tvar first, last, item;\n\n\t\tfunction Item(fn,self) {\n\t\t\tthis.fn = fn;\n\t\t\tthis.self = self;\n\t\t\tthis.next = void 0;\n\t\t}\n\n\t\treturn {\n\t\t\tadd: function add(fn,self) {\n\t\t\t\titem = new Item(fn,self);\n\t\t\t\tif (last) {\n\t\t\t\t\tlast.next = item;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst = item;\n\t\t\t\t}\n\t\t\t\tlast = item;\n\t\t\t\titem = void 0;\n\t\t\t},\n\t\t\tdrain: function drain() {\n\t\t\t\tvar f = first;\n\t\t\t\tfirst = last = cycle = void 0;\n\n\t\t\t\twhile (f) {\n\t\t\t\t\tf.fn.call(f.self);\n\t\t\t\t\tf = f.next;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t})();\n\n\tfunction schedule(fn,self) {\n\t\tscheduling_queue.add(fn,self);\n\t\tif (!cycle) {\n\t\t\tcycle = timer(scheduling_queue.drain);\n\t\t}\n\t}\n\n\t// promise duck typing\n\tfunction isThenable(o) {\n\t\tvar _then, o_type = typeof o;\n\n\t\tif (o != null &&\n\t\t\t(\n\t\t\t\to_type == \"object\" || o_type == \"function\"\n\t\t\t)\n\t\t) {\n\t\t\t_then = o.then;\n\t\t}\n\t\treturn typeof _then == \"function\" ? _then : false;\n\t}\n\n\tfunction notify() {\n\t\tfor (var i=0; i<this.chain.length; i++) {\n\t\t\tnotifyIsolated(\n\t\t\t\tthis,\n\t\t\t\t(this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n\t\t\t\tthis.chain[i]\n\t\t\t);\n\t\t}\n\t\tthis.chain.length = 0;\n\t}\n\n\t// NOTE: This is a separate function to isolate\n\t// the `try..catch` so that other code can be\n\t// optimized better\n\tfunction notifyIsolated(self,cb,chain) {\n\t\tvar ret, _then;\n\t\ttry {\n\t\t\tif (cb === false) {\n\t\t\t\tchain.reject(self.msg);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (cb === true) {\n\t\t\t\t\tret = self.msg;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret = cb.call(void 0,self.msg);\n\t\t\t\t}\n\n\t\t\t\tif (ret === chain.promise) {\n\t\t\t\t\tchain.reject(TypeError(\"Promise-chain cycle\"));\n\t\t\t\t}\n\t\t\t\telse if (_then = isThenable(ret)) {\n\t\t\t\t\t_then.call(ret,chain.resolve,chain.reject);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchain.resolve(ret);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\tchain.reject(err);\n\t\t}\n\t}\n\n\tfunction resolve(msg) {\n\t\tvar _then, self = this;\n\n\t\t// already triggered?\n\t\tif (self.triggered) { return; }\n\n\t\tself.triggered = true;\n\n\t\t// unwrap\n\t\tif (self.def) {\n\t\t\tself = self.def;\n\t\t}\n\n\t\ttry {\n\t\t\tif (_then = isThenable(msg)) {\n\t\t\t\tschedule(function(){\n\t\t\t\t\tvar def_wrapper = new MakeDefWrapper(self);\n\t\t\t\t\ttry {\n\t\t\t\t\t\t_then.call(msg,\n\t\t\t\t\t\t\tfunction $resolve$(){ resolve.apply(def_wrapper,arguments); },\n\t\t\t\t\t\t\tfunction $reject$(){ reject.apply(def_wrapper,arguments); }\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (err) {\n\t\t\t\t\t\treject.call(def_wrapper,err);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\telse {\n\t\t\t\tself.msg = msg;\n\t\t\t\tself.state = 1;\n\t\t\t\tif (self.chain.length > 0) {\n\t\t\t\t\tschedule(notify,self);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (err) {\n\t\t\treject.call(new MakeDefWrapper(self),err);\n\t\t}\n\t}\n\n\tfunction reject(msg) {\n\t\tvar self = this;\n\n\t\t// already triggered?\n\t\tif (self.triggered) { return; }\n\n\t\tself.triggered = true;\n\n\t\t// unwrap\n\t\tif (self.def) {\n\t\t\tself = self.def;\n\t\t}\n\n\t\tself.msg = msg;\n\t\tself.state = 2;\n\t\tif (self.chain.length > 0) {\n\t\t\tschedule(notify,self);\n\t\t}\n\t}\n\n\tfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n\t\tfor (var idx=0; idx<arr.length; idx++) {\n\t\t\t(function IIFE(idx){\n\t\t\t\tConstructor.resolve(arr[idx])\n\t\t\t\t.then(\n\t\t\t\t\tfunction $resolver$(msg){\n\t\t\t\t\t\tresolver(idx,msg);\n\t\t\t\t\t},\n\t\t\t\t\trejecter\n\t\t\t\t);\n\t\t\t})(idx);\n\t\t}\n\t}\n\n\tfunction MakeDefWrapper(self) {\n\t\tthis.def = self;\n\t\tthis.triggered = false;\n\t}\n\n\tfunction MakeDef(self) {\n\t\tthis.promise = self;\n\t\tthis.state = 0;\n\t\tthis.triggered = false;\n\t\tthis.chain = [];\n\t\tthis.msg = void 0;\n\t}\n\n\tfunction Promise(executor) {\n\t\tif (typeof executor != \"function\") {\n\t\t\tthrow TypeError(\"Not a function\");\n\t\t}\n\n\t\tif (this.__NPO__ !== 0) {\n\t\t\tthrow TypeError(\"Not a promise\");\n\t\t}\n\n\t\t// instance shadowing the inherited \"brand\"\n\t\t// to signal an already \"initialized\" promise\n\t\tthis.__NPO__ = 1;\n\n\t\tvar def = new MakeDef(this);\n\n\t\tthis[\"then\"] = function then(success,failure) {\n\t\t\tvar o = {\n\t\t\t\tsuccess: typeof success == \"function\" ? success : true,\n\t\t\t\tfailure: typeof failure == \"function\" ? failure : false\n\t\t\t};\n\t\t\t// Note: `then(..)` itself can be borrowed to be used against\n\t\t\t// a different promise constructor for making the chained promise,\n\t\t\t// by substituting a different `this` binding.\n\t\t\to.promise = new this.constructor(function extractChain(resolve,reject) {\n\t\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t\t}\n\n\t\t\t\to.resolve = resolve;\n\t\t\t\to.reject = reject;\n\t\t\t});\n\t\t\tdef.chain.push(o);\n\n\t\t\tif (def.state !== 0) {\n\t\t\t\tschedule(notify,def);\n\t\t\t}\n\n\t\t\treturn o.promise;\n\t\t};\n\t\tthis[\"catch\"] = function $catch$(failure) {\n\t\t\treturn this.then(void 0,failure);\n\t\t};\n\n\t\ttry {\n\t\t\texecutor.call(\n\t\t\t\tvoid 0,\n\t\t\t\tfunction publicResolve(msg){\n\t\t\t\t\tresolve.call(def,msg);\n\t\t\t\t},\n\t\t\t\tfunction publicReject(msg) {\n\t\t\t\t\treject.call(def,msg);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tcatch (err) {\n\t\t\treject.call(def,err);\n\t\t}\n\t}\n\n\tvar PromisePrototype = builtInProp({},\"constructor\",Promise,\n\t\t/*configurable=*/false\n\t);\n\n\t// Note: Android 4 cannot use `Object.defineProperty(..)` here\n\tPromise.prototype = PromisePrototype;\n\n\t// built-in \"brand\" to signal an \"uninitialized\" promise\n\tbuiltInProp(PromisePrototype,\"__NPO__\",0,\n\t\t/*configurable=*/false\n\t);\n\n\tbuiltInProp(Promise,\"resolve\",function Promise$resolve(msg) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\t// note: best \"isPromise\" check that's practical for now\n\t\tif (msg && typeof msg == \"object\" && msg.__NPO__ === 1) {\n\t\t\treturn msg;\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\tresolve(msg);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"reject\",function Promise$reject(msg) {\n\t\treturn new this(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\treject(msg);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"all\",function Promise$all(arr) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\tif (ToString.call(arr) != \"[object Array]\") {\n\t\t\treturn Constructor.reject(TypeError(\"Not an array\"));\n\t\t}\n\t\tif (arr.length === 0) {\n\t\t\treturn Constructor.resolve([]);\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\tvar len = arr.length, msgs = Array(len), count = 0;\n\n\t\t\titeratePromises(Constructor,arr,function resolver(idx,msg) {\n\t\t\t\tmsgs[idx] = msg;\n\t\t\t\tif (++count === len) {\n\t\t\t\t\tresolve(msgs);\n\t\t\t\t}\n\t\t\t},reject);\n\t\t});\n\t});\n\n\tbuiltInProp(Promise,\"race\",function Promise$race(arr) {\n\t\tvar Constructor = this;\n\n\t\t// spec mandated checks\n\t\tif (ToString.call(arr) != \"[object Array]\") {\n\t\t\treturn Constructor.reject(TypeError(\"Not an array\"));\n\t\t}\n\n\t\treturn new Constructor(function executor(resolve,reject){\n\t\t\tif (typeof resolve != \"function\" || typeof reject != \"function\") {\n\t\t\t\tthrow TypeError(\"Not a function\");\n\t\t\t}\n\n\t\t\titeratePromises(Constructor,arr,function resolver(idx,msg){\n\t\t\t\tresolve(msg);\n\t\t\t},reject);\n\t\t});\n\t});\n\n\treturn Promise;\n});\n\n\n\n// WEBPACK FOOTER //\n// node_modules/native-promise-only/lib/npo.src.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/path-browserify/index.js","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Jeremy Whitlock\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\n/**\n * Utility that provides a single API for loading the content of a path/URL.\n *\n * @module PathLoader\n */\n\nvar supportedLoaders = {\n  file: require('./lib/loaders/file'),\n  http: require('./lib/loaders/http'),\n  https: require('./lib/loaders/http')\n};\nvar defaultLoader = typeof window === 'object' || typeof importScripts === 'function' ?\n      supportedLoaders.http :\n      supportedLoaders.file;\n\n// Load promises polyfill if necessary\n/* istanbul ignore if */\nif (typeof Promise === 'undefined') {\n  require('native-promise-only');\n}\n\nfunction getScheme (location) {\n  if (typeof location !== 'undefined') {\n    location = location.indexOf('://') === -1 ? '' : location.split('://')[0];\n  }\n\n  return location;\n}\n\n/**\n * Callback used to provide access to altering a remote request prior to the request being made.\n *\n * @typedef {function} PrepareRequestCallback\n *\n * @param {object} req - The Superagent request object\n * @param {string} location - The location being retrieved\n * @param {function} callback - First callback\n *\n * @alias module:PathLoader~PrepareRequestCallback\n */\n\n /**\n  * Callback used to provide access to processing the raw response of the request being made. *(HTTP loader only)*\n  *\n  * @typedef {function} ProcessResponseCallback\n  *\n  * @param {object} res - The Superagent response object *(For non-HTTP loaders, this object will be like the Superagent\n  * object in that it will have a `text` property whose value is the raw string value being processed.  This was done\n  * for consistency.)*\n  * @param {function} callback - Error-first callback\n  *\n  * @returns {*} the result of processing the responsexs\n  *\n  * @alias module:PathLoader~ProcessResponseCallback\n  */\n\nfunction getLoader (location) {\n  var scheme = getScheme(location);\n  var loader = supportedLoaders[scheme];\n\n  if (typeof loader === 'undefined') {\n    if (scheme === '') {\n      loader = defaultLoader;\n    } else {\n      throw new Error('Unsupported scheme: ' + scheme);\n    }\n  }\n\n  return loader;\n}\n\n/**\n * Loads a document at the provided location and returns a JavaScript object representation.\n *\n * @param {object} location - The location to the document\n * @param {object} [options] - The options\n * @param {string} [options.encoding='utf-8'] - The encoding to use when loading the file *(File loader only)*\n * @param {string} [options.method=get] - The HTTP method to use for the request *(HTTP loader only)*\n * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare the request\n * *(HTTP loader only)*\n * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the\n * response\n *\n * @returns {Promise} Always returns a promise even if there is a callback provided\n *\n * @example\n * // Example using Promises\n *\n * PathLoader\n *   .load('./package.json')\n *   .then(JSON.parse)\n *   .then(function (document) {\n *     console.log(document.name + ' (' + document.version + '): ' + document.description);\n *   }, function (err) {\n *     console.error(err.stack);\n *   });\n *\n * @example\n * // Example using options.prepareRequest to provide authentication details for a remotely secure URL\n *\n * PathLoader\n *   .load('https://api.github.com/repos/whitlockjc/path-loader', {\n *     prepareRequest: function (req, callback) {\n *       req.auth('my-username', 'my-password');\n *       callback(undefined, req);\n *     }\n *   })\n *   .then(JSON.parse)\n *   .then(function (document) {\n *     console.log(document.full_name + ': ' + document.description);\n *   }, function (err) {\n *     console.error(err.stack);\n *   });\n *\n * @example\n * // Example loading a YAML file\n *\n * PathLoader\n *   .load('/Users/not-you/projects/path-loader/.travis.yml')\n *   .then(YAML.safeLoad)\n *   .then(function (document) {\n *     console.log('path-loader uses the', document.language, 'language.');\n *   }, function (err) {\n *     console.error(err.stack);\n *   });\n *\n * @example\n * // Example loading a YAML file with options.processContent (Useful if you need information in the raw response)\n *\n * PathLoader\n *   .load('/Users/not-you/projects/path-loader/.travis.yml', {\n *     processContent: function (res, callback) {\n *       callback(YAML.safeLoad(res.text));\n *     }\n *   })\n *   .then(function (document) {\n *     console.log('path-loader uses the', document.language, 'language.');\n *   }, function (err) {\n *     console.error(err.stack);\n *   });\n */\nmodule.exports.load = function (location, options) {\n  var allTasks = Promise.resolve();\n\n  // Default options to empty object\n  if (typeof options === 'undefined') {\n    options = {};\n  }\n\n  // Validate arguments\n  allTasks = allTasks.then(function () {\n    if (typeof location === 'undefined') {\n      throw new TypeError('location is required');\n    } else if (typeof location !== 'string') {\n      throw new TypeError('location must be a string');\n    }\n\n    if (typeof options !== 'undefined') {\n      if (typeof options !== 'object') {\n        throw new TypeError('options must be an object');\n      } else if (typeof options.processContent !== 'undefined' && typeof options.processContent !== 'function') {\n        throw new TypeError('options.processContent must be a function');\n      }\n    }\n  });\n\n  // Load the document from the provided location and process it\n  allTasks = allTasks\n    .then(function () {\n      return new Promise(function (resolve, reject) {\n        var loader = getLoader(location);\n\n        loader.load(location, options || {}, function (err, document) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(document);\n          }\n        });\n      });\n    })\n    .then(function (res) {\n      if (options.processContent) {\n        return new Promise(function (resolve, reject) {\n          // For consistency between file and http, always send an object with a 'text' property containing the raw\n          // string value being processed.\n          options.processContent(typeof res === 'object' ? res : {text: res}, function (err, processed) {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(processed);\n            }\n          });\n        });\n      } else {\n        // If there was no content processor, we will assume that for all objects that it is a Superagent response\n        // and will return its `text` property value.  Otherwise, we will return the raw response.\n        return typeof res === 'object' ? res.text : res;\n      }\n    });\n\n  return allTasks;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/path-loader/index.js","/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Jeremy Whitlock\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar unsupportedError = new TypeError('The \\'file\\' scheme is not supported in the browser');\n\n/**\n * The file loader is not supported in the browser.\n *\n * @throws {error} the file loader is not supported in the browser\n */\nmodule.exports.getBase = function () {\n  throw unsupportedError;\n};\n\n/**\n * The file loader is not supported in the browser.\n */\nmodule.exports.load = function () {\n  var fn = arguments[arguments.length - 1];\n\n  if (typeof fn === 'function') {\n    fn(unsupportedError);\n  } else {\n    throw unsupportedError;\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/path-loader/lib/loaders/file-browser.js","/* eslint-env node, browser */\n\n/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Jeremy Whitlock\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n'use strict';\n\nvar request = require('superagent');\n\nvar supportedHttpMethods = ['delete', 'get', 'head', 'patch', 'post', 'put'];\n\n/**\n * Loads a file from an http or https URL.\n *\n * @param {string} location - The document URL (If relative, location is relative to window.location.origin).\n * @param {object} options - The loader options\n * @param {string} [options.method=get] - The HTTP method to use for the request\n * @param {module:PathLoader~PrepareRequestCallback} [options.prepareRequest] - The callback used to prepare a request\n * @param {module:PathLoader~ProcessResponseCallback} [options.processContent] - The callback used to process the\n * response\n * @param {function} callback - The error-first callback\n */\nmodule.exports.load = function (location, options, callback) {\n  var realMethod = options.method ? options.method.toLowerCase() : 'get';\n  var err;\n  var realRequest;\n\n  function makeRequest (err, req) {\n    if (err) {\n      callback(err);\n    } else {\n      // buffer() is only available in Node.js\n      if (typeof req.buffer === 'function') {\n        req.buffer(true);\n      }\n\n      req\n        .end(function (err2, res) {\n          if (err2) {\n            callback(err2);\n          } else {\n            callback(undefined, res);\n          }\n        });\n    }\n  }\n\n  if (typeof options.method !== 'undefined') {\n    if (typeof options.method !== 'string') {\n      err = new TypeError('options.method must be a string');\n    } else if (supportedHttpMethods.indexOf(options.method) === -1) {\n      err = new TypeError('options.method must be one of the following: ' +\n        supportedHttpMethods.slice(0, supportedHttpMethods.length - 1).join(', ') + ' or ' +\n        supportedHttpMethods[supportedHttpMethods.length - 1]);\n    }\n  } else if (typeof options.prepareRequest !== 'undefined' && typeof options.prepareRequest !== 'function') {\n    err = new TypeError('options.prepareRequest must be a function');\n  }\n\n  if (!err) {\n    realRequest = request[realMethod === 'delete' ? 'del' : realMethod](location);\n\n    if (options.prepareRequest) {\n      try {\n        options.prepareRequest(realRequest, makeRequest);\n      } catch (err2) {\n        callback(err2);\n      }\n    } else {\n      makeRequest(undefined, realRequest);\n    }\n  } else {\n    callback(err);\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/path-loader/lib/loaders/http.js","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n// WEBPACK FOOTER //\n// node_modules/process/browser.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/querystring-es3/decode.js","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/querystring-es3/encode.js","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n\n\n\n// WEBPACK FOOTER //\n// node_modules/querystring-es3/index.js","\n/**\n * Reduce `arr` with `fn`.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @param {Mixed} initial\n *\n * TODO: combatible error handling?\n */\n\nmodule.exports = function(arr, fn, initial){  \n  var idx = 0;\n  var len = arr.length;\n  var curr = arguments.length == 3\n    ? initial\n    : arr[idx++];\n\n  while (idx < len) {\n    curr = fn.call(null, curr, arr[idx], ++idx, arr);\n  }\n  \n  return curr;\n};\n\n\n// WEBPACK FOOTER //\n// node_modules/reduce-component/index.js","'use strict';\nmodule.exports = function (str) {\n\tvar isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n\tvar hasNonAscii = /[^\\x00-\\x80]+/.test(str);\n\n\tif (isExtendedLengthPath || hasNonAscii) {\n\t\treturn str;\n\t}\n\n\treturn str.replace(/\\\\/g, '/');\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/slash/index.js","/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\nvar reduce = require('reduce');\nvar requestBase = require('./request-base');\nvar isObject = require('./is-object');\n\n/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  root = this;\n}\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * TODO: future proof, move to compoent land\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isHost(obj) {\n  var str = {}.toString.call(obj);\n\n  switch (str) {\n    case '[object File]':\n    case '[object Blob]':\n    case '[object FormData]':\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * Expose `request`.\n */\n\nvar request = module.exports = require('./request').bind(null, Request);\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  return false;\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    if (null != obj[key]) {\n      pushEncodedKeyValuePair(pairs, key, obj[key]);\n        }\n      }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (Array.isArray(val)) {\n    return val.forEach(function(v) {\n      pushEncodedKeyValuePair(pairs, key, v);\n    });\n  }\n  pairs.push(encodeURIComponent(key)\n    + '=' + encodeURIComponent(val));\n}\n\n/**\n * Expose serialization method.\n */\n\n request.serializeObject = serialize;\n\n /**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var parts;\n  var pair;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    parts = pair.split('=');\n    obj[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'application/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\n request.serialize = {\n   'application/x-www-form-urlencoded': serialize,\n   'application/json': JSON.stringify\n };\n\n /**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  lines.pop(); // trailing CRLF\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  return /[\\/+]json\\b/.test(mime);\n}\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nfunction type(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction params(str){\n  return reduce(str.split(/ *; */), function(obj, str){\n    var parts = str.split(/ *= */)\n      , key = parts.shift()\n      , val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req, options) {\n  options = options || {};\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  this.setStatusProperties(this.xhr.status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this.setHeaderProperties(this.header);\n  this.body = this.req.method != 'HEAD'\n    ? this.parseBody(this.text ? this.text : this.xhr.response)\n    : null;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponse.prototype.get = function(field){\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponse.prototype.setHeaderProperties = function(header){\n  // content-type\n  var ct = this.header['content-type'] || '';\n  this.type = type(ct);\n\n  // params\n  var obj = params(ct);\n  for (var key in obj) this[key] = obj[key];\n};\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype.parseBody = function(str){\n  var parse = request.parse[this.type];\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponse.prototype.setStatusProperties = function(status){\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n\n  var type = status / 100 | 0;\n\n  // status / class\n  this.status = this.statusCode = status;\n  this.statusType = type;\n\n  // basics\n  this.info = 1 == type;\n  this.ok = 2 == type;\n  this.clientError = 4 == type;\n  this.serverError = 5 == type;\n  this.error = (4 == type || 5 == type)\n    ? this.toError()\n    : false;\n\n  // sugar\n  this.accepted = 202 == status;\n  this.noContent = 204 == status;\n  this.badRequest = 400 == status;\n  this.unauthorized = 401 == status;\n  this.notAcceptable = 406 == status;\n  this.notFound = 404 == status;\n  this.forbidden = 403 == status;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      err.rawResponse = self.xhr && self.xhr.responseText ? self.xhr.responseText : null;\n      // issue #876: return the http status code if the response parsing fails\n      err.statusCode = self.xhr && self.xhr.status ? self.xhr.status : null;\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    if (err) {\n      return self.callback(err, res);\n    }\n\n    if (res.status >= 200 && res.status < 300) {\n      return self.callback(err, res);\n    }\n\n    var new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n    new_err.original = err;\n    new_err.response = res;\n    new_err.status = res.status;\n\n    self.callback(new_err, res);\n  });\n}\n\n/**\n * Mixin `Emitter` and `requestBase`.\n */\n\nEmitter(Request.prototype);\nfor (var key in requestBase) {\n  Request.prototype[key] = requestBase[key];\n}\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  if (this.aborted) return;\n  this.aborted = true;\n  this.xhr.abort();\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set responseType to `val`. Presently valid responseTypes are 'blob' and \n * 'arraybuffer'.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} pass\n * @param {Object} options with 'type' property 'auto' or 'basic' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (!options) {\n    options = {\n      type: 'basic'\n    }\n  }\n\n  switch (options.type) {\n    case 'basic':\n      var str = btoa(user + ':' + pass);\n      this.set('Authorization', 'Basic ' + str);\n    break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n    break;\n  }\n  return this;\n};\n\n/**\n* Add query-string `val`.\n*\n* Examples:\n*\n*   request.get('/shoes')\n*     .query('size=10')\n*     .query({ color: 'blue' })\n*\n* @param {Object|String} val\n* @return {Request} for chaining\n* @api public\n*/\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `filename`.\n *\n * ``` js\n * request.post('/upload')\n *   .attach(new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String} filename\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, filename){\n  this._getFormData().append(field, file, filename || file.name);\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n  *      request.post('/user')\n  *        .send('name=tobi')\n  *        .send('species=ferret')\n  *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.send = function(data){\n  var obj = isObject(data);\n  var type = this._header['content-type'];\n\n  // merge\n  if (obj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!obj || isHost(data)) return this;\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * @deprecated\n */\nResponse.prototype.parse = function serialize(fn){\n  if (root.console) {\n    console.warn(\"Client-side parse() method has been renamed to serialize(). This method is not compatible with superagent v2.0\");\n  }\n  this.serialize(fn);\n  return this;\n};\n\nResponse.prototype.serialize = function serialize(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  var fn = this._callback;\n  this.clearTimeout();\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequest.prototype.timeoutError = function(){\n  var timeout = this._timeout;\n  var err = new Error('timeout of ' + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  this.callback(err);\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequest.prototype.withCredentials = function(){\n  this._withCredentials = true;\n  return this;\n};\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  var self = this;\n  var xhr = this.xhr = request.getXHR();\n  var query = this._query.join('&');\n  var timeout = this._timeout;\n  var data = this._formData || this._data;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // state change\n  xhr.onreadystatechange = function(){\n    if (4 != xhr.readyState) return;\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (0 == status) {\n      if (self.timedout) return self.timeoutError();\n      if (self.aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(e){\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = 'download';\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    xhr.onprogress = handleProgress;\n  }\n  try {\n    if (xhr.upload && this.hasListeners('progress')) {\n      xhr.upload.onprogress = handleProgress;\n    }\n  } catch(e) {\n    // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n    // Reported here:\n    // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n  }\n\n  // timeout\n  if (timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self.timedout = true;\n      self.abort();\n    }, timeout);\n  }\n\n  // querystring\n  if (query) {\n    query = request.serializeObject(query);\n    this.url += ~this.url.indexOf('?')\n      ? '&' + query\n      : '?' + query;\n  }\n\n  // initiate request\n  if (this.username && this.password) {\n    xhr.open(this.method, this.url, true, this.username, this.password);\n  } else {\n    xhr.open(this.method, this.url, true);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if ('GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !isHost(data)) {\n    // serialize stuff\n    var contentType = this._header['content-type'];\n    var serialize = this._parser || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) serialize = request.serialize['application/json'];\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n    xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\n\n/**\n * Expose `Request`.\n */\n\nrequest.Request = Request;\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn){\n  var req = request('GET', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn){\n  var req = request('HEAD', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nfunction del(url, fn){\n  var req = request('DELETE', url);\n  if (fn) req.end(fn);\n  return req;\n};\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn){\n  var req = request('PATCH', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} data\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn){\n  var req = request('POST', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} data or fn\n * @param {Function} fn\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn){\n  var req = request('PUT', url);\n  if ('function' == typeof data) fn = data, data = null;\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/superagent/lib/client.js","/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null != obj && 'object' == typeof obj;\n}\n\nmodule.exports = isObject;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/superagent/lib/is-object.js","/**\n * Module of mixed-in functions shared between node and client code\n */\nvar isObject = require('./is-object');\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nexports.clearTimeout = function _clearTimeout(){\n  this._timeout = 0;\n  clearTimeout(this._timer);\n  return this;\n};\n\n/**\n * Force given parser\n *\n * Sets the body parser no matter type.\n *\n * @param {Function}\n * @api public\n */\n\nexports.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set timeout to `ms`.\n *\n * @param {Number} ms\n * @return {Request} for chaining\n * @api public\n */\n\nexports.timeout = function timeout(ms){\n  this._timeout = ms;\n  return this;\n};\n\n/**\n * Faux promise support\n *\n * @param {Function} fulfill\n * @param {Function} reject\n * @return {Request}\n */\n\nexports.then = function then(fulfill, reject) {\n  return this.end(function(err, res) {\n    err ? reject(err) : fulfill(res);\n  });\n}\n\n/**\n * Allow for extension\n */\n\nexports.use = function use(fn) {\n  fn(this);\n  return this;\n}\n\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nexports.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nexports.getHeader = exports.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nexports.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nexports.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val` for \"multipart/form-data\"\n * request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n * ```\n *\n * @param {String} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nexports.field = function(name, val) {\n  this._getFormData().append(name, val);\n  return this;\n};\n\n\n\n// WEBPACK FOOTER //\n// node_modules/superagent/lib/request-base.js","// The node and browser modules expose versions of this with the\n// appropriate constructor function bound as first argument\n/**\n * Issue a request:\n *\n * Examples:\n *\n *    request('GET', '/users').end(callback)\n *    request('/users').end(callback)\n *    request('/users', callback)\n *\n * @param {String} method\n * @param {String|Function} url or callback\n * @return {Request}\n * @api public\n */\n\nfunction request(RequestConstructor, method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new RequestConstructor('GET', method).end(url);\n  }\n\n  // url first\n  if (2 == arguments.length) {\n    return new RequestConstructor('GET', method);\n  }\n\n  return new RequestConstructor(method, url);\n}\n\nmodule.exports = request;\n\n\n\n// WEBPACK FOOTER //\n// node_modules/superagent/lib/request.js","/*! https://mths.be/punycode v1.3.2 by @mathias, modified for URI.js */\r\n\r\nvar punycode = (function () {\r\n\r\n\t/**\r\n\t * The `punycode` object.\r\n\t * @name punycode\r\n\t * @type Object\r\n\t */\r\n\tvar punycode,\r\n\r\n\t/** Highest positive signed 32-bit float value */\r\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\r\n\r\n\t/** Bootstring parameters */\r\n\tbase = 36,\r\n\ttMin = 1,\r\n\ttMax = 26,\r\n\tskew = 38,\r\n\tdamp = 700,\r\n\tinitialBias = 72,\r\n\tinitialN = 128, // 0x80\r\n\tdelimiter = '-', // '\\x2D'\r\n\r\n\t/** Regular expressions */\r\n\tregexPunycode = /^xn--/,\r\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\r\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\r\n\r\n\t/** Error messages */\r\n\terrors = {\r\n\t\t'overflow': 'Overflow: input needs wider integers to process',\r\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\r\n\t\t'invalid-input': 'Invalid input'\r\n\t},\r\n\r\n\t/** Convenience shortcuts */\r\n\tbaseMinusTMin = base - tMin,\r\n\tfloor = Math.floor,\r\n\tstringFromCharCode = String.fromCharCode,\r\n\r\n\t/** Temporary variable */\r\n\tkey;\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/**\r\n\t * A generic error utility function.\r\n\t * @private\r\n\t * @param {String} type The error type.\r\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\r\n\t */\r\n\tfunction error(type) {\r\n\t\tthrow new RangeError(errors[type]);\r\n\t}\r\n\r\n\t/**\r\n\t * A generic `Array#map` utility function.\r\n\t * @private\r\n\t * @param {Array} array The array to iterate over.\r\n\t * @param {Function} callback The function that gets called for every array\r\n\t * item.\r\n\t * @returns {Array} A new array of values returned by the callback function.\r\n\t */\r\n\tfunction map(array, fn) {\r\n\t\tvar length = array.length;\r\n\t\tvar result = [];\r\n\t\twhile (length--) {\r\n\t\t\tresult[length] = fn(array[length]);\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\r\n\t * addresses.\r\n\t * @private\r\n\t * @param {String} domain The domain name or email address.\r\n\t * @param {Function} callback The function that gets called for every\r\n\t * character.\r\n\t * @returns {Array} A new string of characters returned by the callback\r\n\t * function.\r\n\t */\r\n\tfunction mapDomain(string, fn) {\r\n\t\tvar parts = string.split('@');\r\n\t\tvar result = '';\r\n\t\tif (parts.length > 1) {\r\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\r\n\t\t\t// the local part (i.e. everything up to `@`) intact.\r\n\t\t\tresult = parts[0] + '@';\r\n\t\t\tstring = parts[1];\r\n\t\t}\r\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\r\n\t\tstring = string.replace(regexSeparators, '\\x2E');\r\n\t\tvar labels = string.split('.');\r\n\t\tvar encoded = map(labels, fn).join('.');\r\n\t\treturn result + encoded;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an array containing the numeric code points of each Unicode\r\n\t * character in the string. While JavaScript uses UCS-2 internally,\r\n\t * this function will convert a pair of surrogate halves (each of which\r\n\t * UCS-2 exposes as separate characters) into a single code point,\r\n\t * matching UTF-16.\r\n\t * @see `punycode.ucs2.encode`\r\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t * @memberOf punycode.ucs2\r\n\t * @name decode\r\n\t * @param {String} string The Unicode input string (UCS-2).\r\n\t * @returns {Array} The new array of code points.\r\n\t */\r\n\tfunction ucs2decode(string) {\r\n\t\tvar output = [],\r\n\t\t    counter = 0,\r\n\t\t    length = string.length,\r\n\t\t    value,\r\n\t\t    extra;\r\n\t\twhile (counter < length) {\r\n\t\t\tvalue = string.charCodeAt(counter++);\r\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\r\n\t\t\t\t// high surrogate, and there is a next character\r\n\t\t\t\textra = string.charCodeAt(counter++);\r\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\r\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\r\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\r\n\t\t\t\t\toutput.push(value);\r\n\t\t\t\t\tcounter--;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\toutput.push(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a string based on an array of numeric code points.\r\n\t * @see `punycode.ucs2.decode`\r\n\t * @memberOf punycode.ucs2\r\n\t * @name encode\r\n\t * @param {Array} codePoints The array of numeric code points.\r\n\t * @returns {String} The new Unicode string (UCS-2).\r\n\t */\r\n\tfunction ucs2encode(array) {\r\n\t\treturn map(array, function(value) {\r\n\t\t\tvar output = '';\r\n\t\t\tif (value > 0xFFFF) {\r\n\t\t\t\tvalue -= 0x10000;\r\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\r\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\r\n\t\t\t}\r\n\t\t\toutput += stringFromCharCode(value);\r\n\t\t\treturn output;\r\n\t\t}).join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a basic code point into a digit/integer.\r\n\t * @see `digitToBasic()`\r\n\t * @private\r\n\t * @param {Number} codePoint The basic numeric code point value.\r\n\t * @returns {Number} The numeric value of a basic code point (for use in\r\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\r\n\t * the code point does not represent a value.\r\n\t */\r\n\tfunction basicToDigit(codePoint) {\r\n\t\tif (codePoint - 48 < 10) {\r\n\t\t\treturn codePoint - 22;\r\n\t\t}\r\n\t\tif (codePoint - 65 < 26) {\r\n\t\t\treturn codePoint - 65;\r\n\t\t}\r\n\t\tif (codePoint - 97 < 26) {\r\n\t\t\treturn codePoint - 97;\r\n\t\t}\r\n\t\treturn base;\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a digit/integer into a basic code point.\r\n\t * @see `basicToDigit()`\r\n\t * @private\r\n\t * @param {Number} digit The numeric value of a basic code point.\r\n\t * @returns {Number} The basic code point whose value (when used for\r\n\t * representing integers) is `digit`, which needs to be in the range\r\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\r\n\t * used; else, the lowercase form is used. The behavior is undefined\r\n\t * if `flag` is non-zero and `digit` has no uppercase form.\r\n\t */\r\n\tfunction digitToBasic(digit, flag) {\r\n\t\t//  0..25 map to ASCII a..z or A..Z\r\n\t\t// 26..35 map to ASCII 0..9\r\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\r\n\t}\r\n\r\n\t/**\r\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\r\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\r\n\t * @private\r\n\t */\r\n\tfunction adapt(delta, numPoints, firstTime) {\r\n\t\tvar k = 0;\r\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\r\n\t\tdelta += floor(delta / numPoints);\r\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\r\n\t\t\tdelta = floor(delta / baseMinusTMin);\r\n\t\t}\r\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\r\n\t * symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycode string of ASCII-only symbols.\r\n\t * @returns {String} The resulting string of Unicode symbols.\r\n\t */\r\n\tfunction decode(input) {\r\n\t\t// Don't use UCS-2\r\n\t\tvar output = [],\r\n\t\t    inputLength = input.length,\r\n\t\t    out,\r\n\t\t    i = 0,\r\n\t\t    n = initialN,\r\n\t\t    bias = initialBias,\r\n\t\t    basic,\r\n\t\t    j,\r\n\t\t    index,\r\n\t\t    oldi,\r\n\t\t    w,\r\n\t\t    k,\r\n\t\t    digit,\r\n\t\t    t,\r\n\t\t    /** Cached calculation results */\r\n\t\t    baseMinusT;\r\n\r\n\t\t// Handle the basic code points: let `basic` be the number of input code\r\n\t\t// points before the last delimiter, or `0` if there is none, then copy\r\n\t\t// the first basic code points to the output.\r\n\r\n\t\tbasic = input.lastIndexOf(delimiter);\r\n\t\tif (basic < 0) {\r\n\t\t\tbasic = 0;\r\n\t\t}\r\n\r\n\t\tfor (j = 0; j < basic; ++j) {\r\n\t\t\t// if it's not a basic code point\r\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\r\n\t\t\t\terror('not-basic');\r\n\t\t\t}\r\n\t\t\toutput.push(input.charCodeAt(j));\r\n\t\t}\r\n\r\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\r\n\t\t// points were copied; start at the beginning otherwise.\r\n\r\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\r\n\r\n\t\t\t// `index` is the index of the next character to be consumed.\r\n\t\t\t// Decode a generalized variable-length integer into `delta`,\r\n\t\t\t// which gets added to `i`. The overflow checking is easier\r\n\t\t\t// if we increase `i` as we go, then subtract off its starting\r\n\t\t\t// value at the end to obtain `delta`.\r\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\r\n\r\n\t\t\t\tif (index >= inputLength) {\r\n\t\t\t\t\terror('invalid-input');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\r\n\r\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\ti += digit * w;\r\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\r\n\t\t\t\tif (digit < t) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tw *= baseMinusT;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tout = output.length + 1;\r\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\r\n\r\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\r\n\t\t\t// incrementing `n` each time, so we'll fix that now:\r\n\t\t\tif (floor(i / out) > maxInt - n) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tn += floor(i / out);\r\n\t\t\ti %= out;\r\n\r\n\t\t\t// Insert `n` at position `i` of the output\r\n\t\t\toutput.splice(i++, 0, n);\r\n\r\n\t\t}\r\n\r\n\t\treturn ucs2encode(output);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\r\n\t * Punycode string of ASCII-only symbols.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The string of Unicode symbols.\r\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\r\n\t */\r\n\tfunction encode(input) {\r\n\t\tvar n,\r\n\t\t    delta,\r\n\t\t    handledCPCount,\r\n\t\t    basicLength,\r\n\t\t    bias,\r\n\t\t    j,\r\n\t\t    m,\r\n\t\t    q,\r\n\t\t    k,\r\n\t\t    t,\r\n\t\t    currentValue,\r\n\t\t    output = [],\r\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\r\n\t\t    inputLength,\r\n\t\t    /** Cached calculation results */\r\n\t\t    handledCPCountPlusOne,\r\n\t\t    baseMinusT,\r\n\t\t    qMinusT;\r\n\r\n\t\t// Convert the input in UCS-2 to Unicode\r\n\t\tinput = ucs2decode(input);\r\n\r\n\t\t// Cache the length\r\n\t\tinputLength = input.length;\r\n\r\n\t\t// Initialize the state\r\n\t\tn = initialN;\r\n\t\tdelta = 0;\r\n\t\tbias = initialBias;\r\n\r\n\t\t// Handle the basic code points\r\n\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\tcurrentValue = input[j];\r\n\t\t\tif (currentValue < 0x80) {\r\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\thandledCPCount = basicLength = output.length;\r\n\r\n\t\t// `handledCPCount` is the number of code points that have been handled;\r\n\t\t// `basicLength` is the number of basic code points.\r\n\r\n\t\t// Finish the basic string - if it is not empty - with a delimiter\r\n\t\tif (basicLength) {\r\n\t\t\toutput.push(delimiter);\r\n\t\t}\r\n\r\n\t\t// Main encoding loop:\r\n\t\twhile (handledCPCount < inputLength) {\r\n\r\n\t\t\t// All non-basic code points < n have been handled already. Find the next\r\n\t\t\t// larger one:\r\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\t\t\t\tif (currentValue >= n && currentValue < m) {\r\n\t\t\t\t\tm = currentValue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\r\n\t\t\t// but guard against overflow\r\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\r\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\r\n\t\t\t\terror('overflow');\r\n\t\t\t}\r\n\r\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\r\n\t\t\tn = m;\r\n\r\n\t\t\tfor (j = 0; j < inputLength; ++j) {\r\n\t\t\t\tcurrentValue = input[j];\r\n\r\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\r\n\t\t\t\t\terror('overflow');\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (currentValue == n) {\r\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\r\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\r\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\r\n\t\t\t\t\t\tif (q < t) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tqMinusT = q - t;\r\n\t\t\t\t\t\tbaseMinusT = base - t;\r\n\t\t\t\t\t\toutput.push(\r\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\r\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\r\n\t\t\t\t\tdelta = 0;\r\n\t\t\t\t\t++handledCPCount;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t++delta;\r\n\t\t\t++n;\r\n\r\n\t\t}\r\n\t\treturn output.join('');\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Punycode string representing a domain name or an email address\r\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\r\n\t * it doesn't matter if you call it on a string that has already been\r\n\t * converted to Unicode.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The Punycoded domain name or email address to\r\n\t * convert to Unicode.\r\n\t * @returns {String} The Unicode representation of the given Punycode\r\n\t * string.\r\n\t */\r\n\tfunction toUnicode(input) {\r\n\t\treturn mapDomain(input, function(string) {\r\n\t\t\treturn regexPunycode.test(string)\r\n\t\t\t\t? decode(string.slice(4).toLowerCase())\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Converts a Unicode string representing a domain name or an email address to\r\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\r\n\t * i.e. it doesn't matter if you call it with a domain that's already in\r\n\t * ASCII.\r\n\t * @memberOf punycode\r\n\t * @param {String} input The domain name or email address to convert, as a\r\n\t * Unicode string.\r\n\t * @returns {String} The Punycode representation of the given domain name or\r\n\t * email address.\r\n\t */\r\n\tfunction toASCII(input) {\r\n\t\treturn mapDomain(input, function(string) {\r\n\t\t\treturn regexNonASCII.test(string)\r\n\t\t\t\t? 'xn--' + encode(string)\r\n\t\t\t\t: string;\r\n\t\t});\r\n\t}\r\n\r\n\t/*--------------------------------------------------------------------------*/\r\n\r\n\t/** Define the public API */\r\n\tpunycode = {\r\n\t\t/**\r\n\t\t * A string representing the current Punycode.js version number.\r\n\t\t * @memberOf punycode\r\n\t\t * @type String\r\n\t\t */\r\n\t\tversion: '1.3.2',\r\n\t\t/**\r\n\t\t * An object of methods to convert from JavaScript's internal character\r\n\t\t * representation (UCS-2) to Unicode code points, and back.\r\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\r\n\t\t * @memberOf punycode\r\n\t\t * @type Object\r\n\t\t */\r\n\t\tucs2: {\r\n\t\t\tdecode: ucs2decode,\r\n\t\t\tencode: ucs2encode\r\n\t\t},\r\n\t\tdecode: decode,\r\n\t\tencode: encode,\r\n\t\ttoASCII: toASCII,\r\n\t\ttoUnicode: toUnicode\r\n\t};\r\n\r\n\treturn punycode;\r\n}());\r\n\r\nif (typeof COMPILED === \"undefined\" && typeof module !== \"undefined\") module.exports = punycode;\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/punycode.js","///<reference path=\"commonjs.d.ts\"/>\r\nrequire(\"./schemes/http\");\r\nrequire(\"./schemes/urn\");\r\nrequire(\"./schemes/mailto\");\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/schemes.js","///<reference path=\"../uri.ts\"/>\r\nif (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\")\r\n    var URI = require(\"../uri\");\r\nURI.SCHEMES[\"http\"] = URI.SCHEMES[\"https\"] = {\r\n    domainHost: true,\r\n    parse: function (components, options) {\r\n        //report missing host\r\n        if (!components.host) {\r\n            components.error = components.error || \"HTTP URIs must have a host.\";\r\n        }\r\n        return components;\r\n    },\r\n    serialize: function (components, options) {\r\n        //normalize the default port\r\n        if (components.port === (String(components.scheme).toLowerCase() !== \"https\" ? 80 : 443) || components.port === \"\") {\r\n            components.port = undefined;\r\n        }\r\n        //normalize the empty path\r\n        if (!components.path) {\r\n            components.path = \"/\";\r\n        }\r\n        //NOTE: We do not parse query strings for HTTP URIs\r\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\r\n        //and not the HTTP spec. \r\n        return components;\r\n    }\r\n};\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/schemes/http.js","///<reference path=\"../uri.ts\"/>\r\nif (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\") {\r\n    var URI = require(\"../uri\"), punycode = require(\"../punycode\");\r\n}\r\n(function () {\r\n    function merge() {\r\n        var sets = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            sets[_i - 0] = arguments[_i];\r\n        }\r\n        if (sets.length > 1) {\r\n            sets[0] = sets[0].slice(0, -1);\r\n            var xl = sets.length - 1;\r\n            for (var x = 1; x < xl; ++x) {\r\n                sets[x] = sets[x].slice(1, -1);\r\n            }\r\n            sets[xl] = sets[xl].slice(1);\r\n            return sets.join('');\r\n        }\r\n        else {\r\n            return sets[0];\r\n        }\r\n    }\r\n    function subexp(str) {\r\n        return \"(?:\" + str + \")\";\r\n    }\r\n    var O = {}, isIRI = URI.IRI_SUPPORT, \r\n    //RFC 3986\r\n    UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\", HEXDIG$$ = \"[0-9A-Fa-f]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), \r\n    //RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; = \r\n    //ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\",\r\n    //WSP$$ = \"[\\\\x20\\\\x09]\",\r\n    //OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\",  //(%d1-8 / %d11-12 / %d14-31 / %d127)\r\n    //QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$),  //%d33 / %d35-91 / %d93-126 / obs-qtext\r\n    //VCHAR$$ = \"[\\\\x21-\\\\x7E]\",\r\n    //WSP$$ = \"[\\\\x20\\\\x09]\",\r\n    //OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$)),  //%d0 / CR / LF / obs-qtext\r\n    //FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\"),\r\n    //QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$),\r\n    //QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"'),\r\n    ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\", QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\", VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\"), DOT_ATOM_TEXT$ = subexp(ATEXT$$ + \"+\" + subexp(\"\\\\.\" + ATEXT$$ + \"+\") + \"*\"), QUOTED_PAIR$ = subexp(\"\\\\\\\\\" + VCHAR$$), QCONTENT$ = subexp(QTEXT$$ + \"|\" + QUOTED_PAIR$), QUOTED_STRING$ = subexp('\\\\\"' + QCONTENT$ + \"*\" + '\\\\\"'), \r\n    //RFC 6068\r\n    DTEXT_NO_OBS$$ = \"[\\\\x21-\\\\x5A\\\\x5E-\\\\x7E]\", SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\", QCHAR$ = subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$ + \"|\" + SOME_DELIMS$$), DOMAIN$ = subexp(DOT_ATOM_TEXT$ + \"|\" + \"\\\\[\" + DTEXT_NO_OBS$$ + \"*\" + \"\\\\]\"), LOCAL_PART$ = subexp(DOT_ATOM_TEXT$ + \"|\" + QUOTED_STRING$), ADDR_SPEC$ = subexp(LOCAL_PART$ + \"\\\\@\" + DOMAIN$), TO$ = subexp(ADDR_SPEC$ + subexp(\"\\\\,\" + ADDR_SPEC$) + \"*\"), HFNAME$ = subexp(QCHAR$ + \"*\"), HFVALUE$ = HFNAME$, HFIELD$ = subexp(HFNAME$ + \"\\\\=\" + HFVALUE$), HFIELDS2$ = subexp(HFIELD$ + subexp(\"\\\\&\" + HFIELD$) + \"*\"), HFIELDS$ = subexp(\"\\\\?\" + HFIELDS2$), MAILTO_URI = URI.VALIDATE_SUPPORT && new RegExp(\"^mailto\\\\:\" + TO$ + \"?\" + HFIELDS$ + \"?$\"), UNRESERVED = new RegExp(UNRESERVED$$, \"g\"), PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\"), NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\"), NOT_DOMAIN = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", \"[\\\\[]\", DTEXT_NO_OBS$$, \"[\\\\]]\"), \"g\"), NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\"), NOT_HFVALUE = NOT_HFNAME, TO = URI.VALIDATE_SUPPORT && new RegExp(\"^\" + TO$ + \"$\"), HFIELDS = URI.VALIDATE_SUPPORT && new RegExp(\"^\" + HFIELDS2$ + \"$\");\r\n    function toUpperCase(str) {\r\n        return str.toUpperCase();\r\n    }\r\n    function decodeUnreserved(str) {\r\n        var decStr = URI.pctDecChars(str);\r\n        return (!decStr.match(UNRESERVED) ? str : decStr);\r\n    }\r\n    function toArray(obj) {\r\n        return obj !== undefined && obj !== null ? (obj instanceof Array && !obj.callee ? obj : (typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj))) : [];\r\n    }\r\n    URI.SCHEMES[\"mailto\"] = {\r\n        parse: function (components, options) {\r\n            if (URI.VALIDATE_SUPPORT && !components.error) {\r\n                if (components.path && !TO.test(components.path)) {\r\n                    components.error = \"Email address is not valid\";\r\n                }\r\n                else if (components.query && !HFIELDS.test(components.query)) {\r\n                    components.error = \"Header fields are invalid\";\r\n                }\r\n            }\r\n            var to = components.to = (components.path ? components.path.split(\",\") : []);\r\n            components.path = undefined;\r\n            if (components.query) {\r\n                var unknownHeaders = false, headers = {};\r\n                var hfields = components.query.split(\"&\");\r\n                for (var x = 0, xl = hfields.length; x < xl; ++x) {\r\n                    var hfield = hfields[x].split(\"=\");\r\n                    switch (hfield[0]) {\r\n                        case \"to\":\r\n                            var toAddrs = hfield[1].split(\",\");\r\n                            for (var x_1 = 0, xl_1 = toAddrs.length; x_1 < xl_1; ++x_1) {\r\n                                to.push(toAddrs[x_1]);\r\n                            }\r\n                            break;\r\n                        case \"subject\":\r\n                            components.subject = URI.unescapeComponent(hfield[1], options);\r\n                            break;\r\n                        case \"body\":\r\n                            components.body = URI.unescapeComponent(hfield[1], options);\r\n                            break;\r\n                        default:\r\n                            unknownHeaders = true;\r\n                            headers[URI.unescapeComponent(hfield[0], options)] = URI.unescapeComponent(hfield[1], options);\r\n                            break;\r\n                    }\r\n                }\r\n                if (unknownHeaders)\r\n                    components.headers = headers;\r\n            }\r\n            components.query = undefined;\r\n            for (var x = 0, xl = to.length; x < xl; ++x) {\r\n                var addr = to[x].split(\"@\");\r\n                addr[0] = URI.unescapeComponent(addr[0]);\r\n                if (typeof punycode !== \"undefined\" && !options.unicodeSupport) {\r\n                    //convert Unicode IDN -> ASCII IDN\r\n                    try {\r\n                        addr[1] = punycode.toASCII(URI.unescapeComponent(addr[1], options).toLowerCase());\r\n                    }\r\n                    catch (e) {\r\n                        components.error = components.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\r\n                    }\r\n                }\r\n                else {\r\n                    addr[1] = URI.unescapeComponent(addr[1], options).toLowerCase();\r\n                }\r\n                to[x] = addr.join(\"@\");\r\n            }\r\n            return components;\r\n        },\r\n        serialize: function (components, options) {\r\n            var to = toArray(components.to);\r\n            if (to) {\r\n                for (var x = 0, xl = to.length; x < xl; ++x) {\r\n                    var toAddr = String(to[x]);\r\n                    var atIdx = toAddr.lastIndexOf(\"@\");\r\n                    var localPart = toAddr.slice(0, atIdx);\r\n                    var domain = toAddr.slice(atIdx + 1);\r\n                    localPart = localPart.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, URI.pctEncChar);\r\n                    if (typeof punycode !== \"undefined\") {\r\n                        //convert IDN via punycode\r\n                        try {\r\n                            domain = (!options.iri ? punycode.toASCII(URI.unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain));\r\n                        }\r\n                        catch (e) {\r\n                            components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\r\n                        }\r\n                    }\r\n                    else {\r\n                        domain = domain.replace(PCT_ENCODED, decodeUnreserved).toLowerCase().replace(PCT_ENCODED, toUpperCase).replace(NOT_DOMAIN, URI.pctEncChar);\r\n                    }\r\n                    to[x] = localPart + \"@\" + domain;\r\n                }\r\n                components.path = to.join(\",\");\r\n            }\r\n            var headers = components.headers = components.headers || {};\r\n            if (components.subject)\r\n                headers[\"subject\"] = components.subject;\r\n            if (components.body)\r\n                headers[\"body\"] = components.body;\r\n            var fields = [];\r\n            for (var name_1 in headers) {\r\n                if (headers[name_1] !== O[name_1]) {\r\n                    fields.push(name_1.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, URI.pctEncChar) +\r\n                        \"=\" +\r\n                        headers[name_1].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, URI.pctEncChar));\r\n                }\r\n            }\r\n            if (fields.length) {\r\n                components.query = fields.join(\"&\");\r\n            }\r\n            return components;\r\n        }\r\n    };\r\n})();\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/schemes/mailto.js","///<reference path=\"../uri.ts\"/>\r\nif (typeof COMPILED === \"undefined\" && typeof URI === \"undefined\" && typeof require === \"function\")\r\n    var URI = require(\"../uri\");\r\n(function () {\r\n    var pctEncChar = URI.pctEncChar, NID$ = \"(?:[0-9A-Za-z][0-9A-Za-z\\\\-]{1,31})\", PCT_ENCODED$ = \"(?:\\\\%[0-9A-Fa-f]{2})\", TRANS$$ = \"[0-9A-Za-z\\\\(\\\\)\\\\+\\\\,\\\\-\\\\.\\\\:\\\\=\\\\@\\\\;\\\\$\\\\_\\\\!\\\\*\\\\'\\\\/\\\\?\\\\#]\", NSS$ = \"(?:(?:\" + PCT_ENCODED$ + \"|\" + TRANS$$ + \")+)\", URN_SCHEME = new RegExp(\"^urn\\\\:(\" + NID$ + \")$\"), URN_PATH = new RegExp(\"^(\" + NID$ + \")\\\\:(\" + NSS$ + \")$\"), URN_PARSE = /^([^\\:]+)\\:(.*)/, URN_EXCLUDED = /[\\x00-\\x20\\\\\\\"\\&\\<\\>\\[\\]\\^\\`\\{\\|\\}\\~\\x7F-\\xFF]/g, UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\r\n    //RFC 2141\r\n    URI.SCHEMES[\"urn\"] = {\r\n        parse: function (components, options) {\r\n            var matches = components.path.match(URN_PATH), scheme, schemeHandler;\r\n            if (!matches) {\r\n                if (!options.tolerant) {\r\n                    components.error = components.error || \"URN is not strictly valid.\";\r\n                }\r\n                matches = components.path.match(URN_PARSE);\r\n            }\r\n            if (matches) {\r\n                scheme = \"urn:\" + matches[1].toLowerCase();\r\n                schemeHandler = URI.SCHEMES[scheme];\r\n                //in order to serialize properly, \r\n                //every URN must have a serializer that calls the URN serializer \r\n                if (!schemeHandler) {\r\n                    //create fake scheme handler\r\n                    schemeHandler = URI.SCHEMES[scheme] = {\r\n                        parse: function (components, options) {\r\n                            return components;\r\n                        },\r\n                        serialize: URI.SCHEMES[\"urn\"].serialize\r\n                    };\r\n                }\r\n                components.scheme = scheme;\r\n                components.path = matches[2];\r\n                components = schemeHandler.parse(components, options);\r\n            }\r\n            else {\r\n                components.error = components.error || \"URN can not be parsed.\";\r\n            }\r\n            return components;\r\n        },\r\n        serialize: function (components, options) {\r\n            var scheme = components.scheme || options.scheme, matches;\r\n            if (scheme && scheme !== \"urn\") {\r\n                var matches = scheme.match(URN_SCHEME);\r\n                if (!matches) {\r\n                    matches = [\"urn:\" + scheme, scheme];\r\n                }\r\n                components.scheme = \"urn\";\r\n                components.path = matches[1] + \":\" + (components.path ? components.path.replace(URN_EXCLUDED, pctEncChar) : \"\");\r\n            }\r\n            return components;\r\n        }\r\n    };\r\n    //RFC 4122\r\n    URI.SCHEMES[\"urn:uuid\"] = {\r\n        parse: function (components, options) {\r\n            if (!options.tolerant && (!components.path || !components.path.match(UUID))) {\r\n                components.error = components.error || \"UUID is not valid.\";\r\n            }\r\n            return components;\r\n        },\r\n        serialize: function (components, options) {\r\n            //ensure UUID is valid\r\n            if (!options.tolerant && (!components.path || !components.path.match(UUID))) {\r\n                //invalid UUIDs can not have this scheme\r\n                components.scheme = undefined;\r\n            }\r\n            else {\r\n                //normalize UUID\r\n                components.path = (components.path || \"\").toLowerCase();\r\n            }\r\n            return URI.SCHEMES[\"urn\"].serialize(components, options);\r\n        }\r\n    };\r\n}());\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/schemes/urn.js","/**\r\n * URI.js\r\n *\r\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\r\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\r\n * @version 2.0.0\r\n * @see http://github.com/garycourt/uri-js\r\n * @license URI.js v2.0.0 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js\r\n */\r\n/**\r\n * Copyright 2011 Gary Court. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification, are\r\n * permitted provided that the following conditions are met:\r\n *\r\n *    1. Redistributions of source code must retain the above copyright notice, this list of\r\n *       conditions and the following disclaimer.\r\n *\r\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\r\n *       of conditions and the following disclaimer in the documentation and/or other materials\r\n *       provided with the distribution.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\r\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\r\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\r\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\r\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * The views and conclusions contained in the software and documentation are those of the\r\n * authors and should not be interpreted as representing official policies, either expressed\r\n * or implied, of Gary Court.\r\n */\r\n///<reference path=\"punycode.d.ts\"/>\r\n///<reference path=\"commonjs.d.ts\"/>\r\n/**\r\n * Compiler switch for indicating code is compiled\r\n * @define {boolean}\r\n */\r\nvar COMPILED = false;\r\n/**\r\n * Compiler switch for supporting IRI URIs\r\n * @define {boolean}\r\n */\r\nvar URI__IRI_SUPPORT = true;\r\n/**\r\n * Compiler switch for supporting URI validation\r\n * @define {boolean}\r\n */\r\nvar URI__VALIDATE_SUPPORT = true;\r\nvar URI = (function () {\r\n    function merge() {\r\n        var sets = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            sets[_i - 0] = arguments[_i];\r\n        }\r\n        if (sets.length > 1) {\r\n            sets[0] = sets[0].slice(0, -1);\r\n            var xl = sets.length - 1;\r\n            for (var x = 1; x < xl; ++x) {\r\n                sets[x] = sets[x].slice(1, -1);\r\n            }\r\n            sets[xl] = sets[xl].slice(1);\r\n            return sets.join('');\r\n        }\r\n        else {\r\n            return sets[0];\r\n        }\r\n    }\r\n    function subexp(str) {\r\n        return \"(?:\" + str + \")\";\r\n    }\r\n    function buildExps(isIRI) {\r\n        var ALPHA$$ = \"[A-Za-z]\", CR$ = \"[\\\\x0D]\", DIGIT$$ = \"[0-9]\", DQUOTE$$ = \"[\\\\x22]\", HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"), LF$$ = \"[\\\\x0A]\", SP$$ = \"[\\\\x20]\", PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)), GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\", SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\", IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\", UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"), USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"), DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$ + \"\\\\.\" + DEC_OCTET$), H16$ = subexp(HEXDIG$$ + \"{1,4}\"), LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$), IPV6ADDRESS$ = subexp(merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IPVFUTURE$ = subexp(\"v\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"), IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"), REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"), HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$), PORT$ = subexp(DIGIT$$ + \"*\"), AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"), PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")), SEGMENT$ = subexp(PCHAR$ + \"*\"), SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"), PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"), PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\", PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"), FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"), HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"), URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"), GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\", SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\", AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\r\n        return {\r\n            URI_REF: URI__VALIDATE_SUPPORT && new RegExp(\"(\" + GENERIC_REF$ + \")|(\" + RELATIVE_REF$ + \")\"),\r\n            NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\r\n            NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            NOT_HOST: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\r\n            NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\r\n            ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\r\n            UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\r\n            OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\r\n            PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\")\r\n        };\r\n    }\r\n    var URI_PROTOCOL = buildExps(false), IRI_PROTOCOL = URI__IRI_SUPPORT ? buildExps(true) : undefined, URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?([^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n)*))?/i, RDS1 = /^\\.\\.?\\//, RDS2 = /^\\/\\.(\\/|$)/, RDS3 = /^\\/\\.\\.(\\/|$)/, RDS4 = /^\\.\\.?$/, RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/, NO_MATCH_IS_UNDEFINED = (\"\").match(/(){0}/)[1] === undefined;\r\n    function pctEncChar(chr) {\r\n        var c = chr.charCodeAt(0), e;\r\n        if (c < 16)\r\n            e = \"%0\" + c.toString(16).toUpperCase();\r\n        else if (c < 128)\r\n            e = \"%\" + c.toString(16).toUpperCase();\r\n        else if (c < 2048)\r\n            e = \"%\" + ((c >> 6) | 192).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\r\n        else\r\n            e = \"%\" + ((c >> 12) | 224).toString(16).toUpperCase() + \"%\" + (((c >> 6) & 63) | 128).toString(16).toUpperCase() + \"%\" + ((c & 63) | 128).toString(16).toUpperCase();\r\n        return e;\r\n    }\r\n    function pctDecChars(str) {\r\n        var newStr = \"\", i = 0, il = str.length, c, c2, c3;\r\n        while (i < il) {\r\n            c = parseInt(str.substr(i + 1, 2), 16);\r\n            if (c < 128) {\r\n                newStr += String.fromCharCode(c);\r\n                i += 3;\r\n            }\r\n            else if (c >= 194 && c < 224) {\r\n                if ((il - i) >= 6) {\r\n                    c2 = parseInt(str.substr(i + 4, 2), 16);\r\n                    newStr += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\r\n                }\r\n                else {\r\n                    newStr += str.substr(i, 6);\r\n                }\r\n                i += 6;\r\n            }\r\n            else if (c >= 224) {\r\n                if ((il - i) >= 9) {\r\n                    c2 = parseInt(str.substr(i + 4, 2), 16);\r\n                    c3 = parseInt(str.substr(i + 7, 2), 16);\r\n                    newStr += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\r\n                }\r\n                else {\r\n                    newStr += str.substr(i, 9);\r\n                }\r\n                i += 9;\r\n            }\r\n            else {\r\n                newStr += str.substr(i, 3);\r\n                i += 3;\r\n            }\r\n        }\r\n        return newStr;\r\n    }\r\n    function typeOf(o) {\r\n        return o === undefined ? \"undefined\" : (o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase());\r\n    }\r\n    function toUpperCase(str) {\r\n        return str.toUpperCase();\r\n    }\r\n    var SCHEMES = {};\r\n    function _normalizeComponentEncoding(components, protocol) {\r\n        function decodeUnreserved(str) {\r\n            var decStr = pctDecChars(str);\r\n            return (!decStr.match(protocol.UNRESERVED) ? str : decStr);\r\n        }\r\n        if (components.scheme)\r\n            components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\r\n        if (components.userinfo !== undefined)\r\n            components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        if (components.host !== undefined)\r\n            components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        if (components.path !== undefined)\r\n            components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace((components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME), pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        if (components.query !== undefined)\r\n            components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        if (components.fragment !== undefined)\r\n            components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\r\n        return components;\r\n    }\r\n    ;\r\n    function parse(uriString, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var protocol = (URI__IRI_SUPPORT && options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL), matches, parseError = false, components = {}, schemeHandler;\r\n        if (options.reference === \"suffix\")\r\n            uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\r\n        if (URI__VALIDATE_SUPPORT) {\r\n            matches = uriString.match(protocol.URI_REF);\r\n            if (matches) {\r\n                if (matches[1]) {\r\n                    //generic URI\r\n                    matches = matches.slice(1, 10);\r\n                }\r\n                else {\r\n                    //relative URI\r\n                    matches = matches.slice(10, 19);\r\n                }\r\n            }\r\n            if (!matches) {\r\n                parseError = true;\r\n                if (!options.tolerant)\r\n                    components.error = components.error || \"URI is not strictly valid.\";\r\n                matches = uriString.match(URI_PARSE);\r\n            }\r\n        }\r\n        else {\r\n            matches = uriString.match(URI_PARSE);\r\n        }\r\n        if (matches) {\r\n            if (NO_MATCH_IS_UNDEFINED) {\r\n                //store each component\r\n                components.scheme = matches[1];\r\n                //components.authority = matches[2];\r\n                components.userinfo = matches[3];\r\n                components.host = matches[4];\r\n                components.port = parseInt(matches[5], 10);\r\n                components.path = matches[6] || \"\";\r\n                components.query = matches[7];\r\n                components.fragment = matches[8];\r\n                //fix port number\r\n                if (isNaN(components.port)) {\r\n                    components.port = matches[5];\r\n                }\r\n            }\r\n            else {\r\n                //store each component\r\n                components.scheme = matches[1] || undefined;\r\n                //components.authority = (uriString.indexOf(\"//\") !== -1 ? matches[2] : undefined);\r\n                components.userinfo = (uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined);\r\n                components.host = (uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined);\r\n                components.port = parseInt(matches[5], 10);\r\n                components.path = matches[6] || \"\";\r\n                components.query = (uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined);\r\n                components.fragment = (uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined);\r\n                //fix port number\r\n                if (isNaN(components.port)) {\r\n                    components.port = (uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined);\r\n                }\r\n            }\r\n            //determine reference type\r\n            if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\r\n                components.reference = \"same-document\";\r\n            }\r\n            else if (components.scheme === undefined) {\r\n                components.reference = \"relative\";\r\n            }\r\n            else if (components.fragment === undefined) {\r\n                components.reference = \"absolute\";\r\n            }\r\n            else {\r\n                components.reference = \"uri\";\r\n            }\r\n            //check for reference errors\r\n            if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\r\n                components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\r\n            }\r\n            //find scheme handler\r\n            schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\r\n            //check if scheme can't handle IRIs\r\n            if (URI__IRI_SUPPORT && typeof punycode !== \"undefined\" && !options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\r\n                //if host component is a domain name\r\n                if (components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\r\n                    //convert Unicode IDN -> ASCII IDN\r\n                    try {\r\n                        components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\r\n                    }\r\n                    catch (e) {\r\n                        components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\r\n                    }\r\n                }\r\n                //convert IRI -> URI\r\n                _normalizeComponentEncoding(components, URI_PROTOCOL);\r\n            }\r\n            else {\r\n                //normalize encodings\r\n                _normalizeComponentEncoding(components, protocol);\r\n            }\r\n            //perform scheme specific parsing\r\n            if (schemeHandler && schemeHandler.parse) {\r\n                schemeHandler.parse(components, options);\r\n            }\r\n        }\r\n        else {\r\n            parseError = true;\r\n            components.error = components.error || \"URI can not be parsed.\";\r\n        }\r\n        return components;\r\n    }\r\n    ;\r\n    function _recomposeAuthority(components, options) {\r\n        var uriTokens = [];\r\n        if (components.userinfo !== undefined) {\r\n            uriTokens.push(components.userinfo);\r\n            uriTokens.push(\"@\");\r\n        }\r\n        if (components.host !== undefined) {\r\n            uriTokens.push(components.host);\r\n        }\r\n        if (typeof components.port === \"number\") {\r\n            uriTokens.push(\":\");\r\n            uriTokens.push(components.port.toString(10));\r\n        }\r\n        return uriTokens.length ? uriTokens.join(\"\") : undefined;\r\n    }\r\n    ;\r\n    function removeDotSegments(input) {\r\n        var output = [], s;\r\n        while (input.length) {\r\n            if (input.match(RDS1)) {\r\n                input = input.replace(RDS1, \"\");\r\n            }\r\n            else if (input.match(RDS2)) {\r\n                input = input.replace(RDS2, \"/\");\r\n            }\r\n            else if (input.match(RDS3)) {\r\n                input = input.replace(RDS3, \"/\");\r\n                output.pop();\r\n            }\r\n            else if (input === \".\" || input === \"..\") {\r\n                input = \"\";\r\n            }\r\n            else {\r\n                s = input.match(RDS5)[0];\r\n                input = input.slice(s.length);\r\n                output.push(s);\r\n            }\r\n        }\r\n        return output.join(\"\");\r\n    }\r\n    ;\r\n    function serialize(components, options) {\r\n        if (options === void 0) { options = {}; }\r\n        var protocol = (URI__IRI_SUPPORT && options.iri ? IRI_PROTOCOL : URI_PROTOCOL), uriTokens = [], schemeHandler, authority, s;\r\n        //find scheme handler\r\n        schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\r\n        //perform scheme specific serialization\r\n        if (schemeHandler && schemeHandler.serialize)\r\n            schemeHandler.serialize(components, options);\r\n        //if host component is a domain name\r\n        if (URI__IRI_SUPPORT && typeof punycode !== \"undefined\" && components.host && (options.domainHost || (schemeHandler && schemeHandler.domainHost))) {\r\n            //convert IDN via punycode\r\n            try {\r\n                components.host = (!options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host));\r\n            }\r\n            catch (e) {\r\n                components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\r\n            }\r\n        }\r\n        //normalize encoding\r\n        _normalizeComponentEncoding(components, protocol);\r\n        if (options.reference !== \"suffix\" && components.scheme) {\r\n            uriTokens.push(components.scheme);\r\n            uriTokens.push(\":\");\r\n        }\r\n        authority = _recomposeAuthority(components, options);\r\n        if (authority !== undefined) {\r\n            if (options.reference !== \"suffix\") {\r\n                uriTokens.push(\"//\");\r\n            }\r\n            uriTokens.push(authority);\r\n            if (components.path && components.path.charAt(0) !== \"/\") {\r\n                uriTokens.push(\"/\");\r\n            }\r\n        }\r\n        if (components.path !== undefined) {\r\n            s = components.path;\r\n            if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\r\n                s = removeDotSegments(s);\r\n            }\r\n            if (authority === undefined) {\r\n                s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\r\n            }\r\n            uriTokens.push(s);\r\n        }\r\n        if (components.query !== undefined) {\r\n            uriTokens.push(\"?\");\r\n            uriTokens.push(components.query);\r\n        }\r\n        if (components.fragment !== undefined) {\r\n            uriTokens.push(\"#\");\r\n            uriTokens.push(components.fragment);\r\n        }\r\n        return uriTokens.join(''); //merge tokens into a string\r\n    }\r\n    ;\r\n    function resolveComponents(base, relative, options, skipNormalization) {\r\n        if (options === void 0) { options = {}; }\r\n        var target = {};\r\n        if (!skipNormalization) {\r\n            base = parse(serialize(base, options), options); //normalize base components\r\n            relative = parse(serialize(relative, options), options); //normalize relative components\r\n        }\r\n        options = options || {};\r\n        if (!options.tolerant && relative.scheme) {\r\n            target.scheme = relative.scheme;\r\n            //target.authority = relative.authority;\r\n            target.userinfo = relative.userinfo;\r\n            target.host = relative.host;\r\n            target.port = relative.port;\r\n            target.path = removeDotSegments(relative.path);\r\n            target.query = relative.query;\r\n        }\r\n        else {\r\n            if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\r\n                //target.authority = relative.authority;\r\n                target.userinfo = relative.userinfo;\r\n                target.host = relative.host;\r\n                target.port = relative.port;\r\n                target.path = removeDotSegments(relative.path);\r\n                target.query = relative.query;\r\n            }\r\n            else {\r\n                if (!relative.path) {\r\n                    target.path = base.path;\r\n                    if (relative.query !== undefined) {\r\n                        target.query = relative.query;\r\n                    }\r\n                    else {\r\n                        target.query = base.query;\r\n                    }\r\n                }\r\n                else {\r\n                    if (relative.path.charAt(0) === \"/\") {\r\n                        target.path = removeDotSegments(relative.path);\r\n                    }\r\n                    else {\r\n                        if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\r\n                            target.path = \"/\" + relative.path;\r\n                        }\r\n                        else if (!base.path) {\r\n                            target.path = relative.path;\r\n                        }\r\n                        else {\r\n                            target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\r\n                        }\r\n                        target.path = removeDotSegments(target.path);\r\n                    }\r\n                    target.query = relative.query;\r\n                }\r\n                //target.authority = base.authority;\r\n                target.userinfo = base.userinfo;\r\n                target.host = base.host;\r\n                target.port = base.port;\r\n            }\r\n            target.scheme = base.scheme;\r\n        }\r\n        target.fragment = relative.fragment;\r\n        return target;\r\n    }\r\n    ;\r\n    function resolve(baseURI, relativeURI, options) {\r\n        return serialize(resolveComponents(parse(baseURI, options), parse(relativeURI, options), options, true), options);\r\n    }\r\n    ;\r\n    function normalize(uri, options) {\r\n        if (typeof uri === \"string\") {\r\n            uri = serialize(parse(uri, options), options);\r\n        }\r\n        else if (typeOf(uri) === \"object\") {\r\n            uri = parse(serialize(uri, options), options);\r\n        }\r\n        return uri;\r\n    }\r\n    ;\r\n    function equal(uriA, uriB, options) {\r\n        if (typeof uriA === \"string\") {\r\n            uriA = serialize(parse(uriA, options), options);\r\n        }\r\n        else if (typeOf(uriA) === \"object\") {\r\n            uriA = serialize(uriA, options);\r\n        }\r\n        if (typeof uriB === \"string\") {\r\n            uriB = serialize(parse(uriB, options), options);\r\n        }\r\n        else if (typeOf(uriB) === \"object\") {\r\n            uriB = serialize(uriB, options);\r\n        }\r\n        return uriA === uriB;\r\n    }\r\n    ;\r\n    function escapeComponent(str, options) {\r\n        return str && str.toString().replace((!URI__IRI_SUPPORT || !options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE), pctEncChar);\r\n    }\r\n    ;\r\n    function unescapeComponent(str, options) {\r\n        return str && str.toString().replace((!URI__IRI_SUPPORT || !options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED), pctDecChars);\r\n    }\r\n    ;\r\n    return {\r\n        IRI_SUPPORT: URI__IRI_SUPPORT,\r\n        VALIDATE_SUPPORT: URI__VALIDATE_SUPPORT,\r\n        pctEncChar: pctEncChar,\r\n        pctDecChars: pctDecChars,\r\n        SCHEMES: SCHEMES,\r\n        parse: parse,\r\n        _recomposeAuthority: _recomposeAuthority,\r\n        removeDotSegments: removeDotSegments,\r\n        serialize: serialize,\r\n        resolveComponents: resolveComponents,\r\n        resolve: resolve,\r\n        normalize: normalize,\r\n        equal: equal,\r\n        escapeComponent: escapeComponent,\r\n        unescapeComponent: unescapeComponent\r\n    };\r\n})();\r\nif (!COMPILED && typeof module !== \"undefined\" && typeof require === \"function\") {\r\n    var punycode = require(\"./punycode\");\r\n    module.exports = URI;\r\n    require(\"./schemes\");\r\n}\r\n\n\n\n// WEBPACK FOOTER //\n// node_modules/uri-js/build/uri.js","import {stringify, parse} from './sf-path';\nimport { defaultForm, createDefaults } from './schema-defaults';\nimport canonicalTitleMap from './canonical-title-map';\n\n// export function merge(schema, form, schemaDefaultTypes, ignore, options, readonly, asyncTemplates) {\nexport function merge(lookup, form, typeDefaults=createDefaults(), ignore, options, readonly, asyncTemplates) {\n  let formItems = [];\n  let formItemRest = [];\n  form  = form || [];\n  let idx = form.indexOf('*');\n  options = options || {};\n  let stdForm = {};\n\n  let idxRest = form.indexOf('...');\n  if(typeof lookup === 'object' && lookup.hasOwnProperty('properties')) {\n    readonly = readonly || lookup.readonly || lookup.readOnly;\n    stdForm = defaultForm(lookup, typeDefaults, ignore, options);\n\n    let defaultFormLookup = stdForm.lookup;\n\n    lookup = defaultFormLookup || lookup;\n    formItems = formItems.concat(stdForm.form);\n  };\n\n  if (idx !== -1) {\n    form = form.slice(0, idx).concat(formItems).concat(form.slice(idx + 1));\n  }\n\n  //simple case, we have a \"...\", just put the formItemRest there\n  if (stdForm.form && idxRest !== -1) {\n    let formKeys = form.map(function(obj) {\n      if (typeof obj === 'string'){\n        return obj;\n      }\n      else if (obj.key) {\n        return obj.key;\n      };\n    }).filter(function(element) {\n      return element !== undefined;\n    });\n\n    formItemRest = formItemRest.concat(\n      stdForm.form.map(function(obj) {\n        let isInside = formKeys.indexOf(obj.key[0]) !== -1;\n        if (!isInside) {\n          return obj;\n        };\n      })\n      .filter(function(element) {\n        return element !== undefined;\n      })\n    );\n  };\n\n  if (idxRest !== -1) {\n    form = form.slice(0, idxRest).concat(formItemRest).concat(form.slice(idxRest + 1));\n  };\n\n  // ok let's merge!\n  // We look at the supplied form and extend it with schema standards\n  return form.map((obj) => {\n    // handle the shortcut with just a name\n    if (typeof obj === 'string') {\n      obj = { key: obj };\n    }\n\n    if (obj.key) {\n      if (typeof obj.key === 'string') {\n        obj.key = parse(obj.key);\n      }\n    }\n\n    // If it has a titleMap make sure it's a list\n    if (obj.titleMap) {\n      obj.titleMap = canonicalTitleMap(obj.titleMap);\n    }\n\n    // extend with std form from schema.\n    if (obj.key) {\n      const strid = stringify(obj.key);\n      if (lookup[strid]) {\n        const schemaDefaults = lookup[strid];\n        if (schemaDefaults) {\n          Object.keys(schemaDefaults).forEach((attr) => {\n            if (obj[attr] === undefined) {\n              obj[attr] = schemaDefaults[attr];\n            }\n          });\n        }\n      }\n    }\n\n    // Are we inheriting readonly?\n    if (readonly === true) { // Inheriting false is not cool.\n      obj.readonly = true;\n    }\n\n    // if it's a type with items, merge 'em!\n    if (obj.items) {\n      obj.items = merge(lookup, obj.items, typeDefaults, ignore, options, obj.readonly, asyncTemplates);\n    }\n\n    // if its has tabs, merge them also!\n    if (obj.tabs) {\n      obj.tabs.forEach((tab) => {\n        if (tab.items) {\n          tab.items = merge(lookup, tab.items, typeDefaults, ignore, options, obj.readonly, asyncTemplates);\n        }\n      });\n    }\n\n    // Special case: checkbox\n    // Since have to ternary state we need a default\n    if (obj.type === 'checkbox') {\n      // Check for schema property, as the checkbox may be part of the explicitly defined form\n      if (obj.schema === undefined) {\n        obj.schema = { default: false };\n      }\n      else if (obj.schema['default'] === undefined) {\n        obj.schema['default'] = false;\n      };\n    };\n\n    // Special case: template type with tempplateUrl that's needs to be loaded before rendering\n    // TODO: this is not a clean solution. Maybe something cleaner can be made when $ref support\n    // is introduced since we need to go async then anyway\n    if (asyncTemplates && obj.type === 'template' && !obj.template && obj.templateUrl) {\n      asyncTemplates.push(obj);\n    };\n\n    return obj;\n  });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/merge.js","import * as JsonRefs from './../../lib/json-refs-standalone';\n\nexport function jsonref(schema, callBack) {\n  let promise = new Promise(\n    function(resolve, reject) {\n      JsonRefs.resolveRefs(schema, {\n        \"filter\": [ 'relative', 'local', 'remote' ]\n      })\n        .then((res) => { resolve(res.resolved); })\n        .catch((err) => { reject(new Error(err)); });\n    }\n  );\n\n  if(typeof(callBack) === 'function') {\n    promise\n      .then((resolved) => { callBack(null, resolved); })\n      .catch((error) => { callBack(error); });\n  }\n  else {\n    return promise;\n  }\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/resolve.js","import * as sfPath from './sf-path';\n\nconst numRe = /^\\d+$/;\n\n/**\n  * @description\n  * Utility method to access deep properties without\n  * throwing errors when things are not defined.\n  * Can also set a value in a deep structure, creating objects when missing\n  * ex.\n  * var foo = Select('address.contact.name',obj)\n  * Select('address.contact.name',obj,'Leeroy')\n  *\n  * @param {string} projection A dot path to the property you want to get/set\n  * @param {object} obj   (optional) The object to project on, defaults to 'this'\n  * @param {Any}    valueToSet (opional)  The value to set, if parts of the path of\n  *                 the projection is missing empty objects will be created.\n  * @returns {Any|undefined} returns the value at the end of the projection path\n  *                          or undefined if there is none.\n  */\nexport function select(projection, obj, valueToSet) {\n  if (!obj) {\n    obj = this;\n  };\n\n  // Support [] array syntax\n  let parts = typeof projection === 'string' ? sfPath.parse(projection) : projection;\n\n  if (typeof valueToSet !== 'undefined' && parts.length === 1) {\n    // special case, just setting one variable\n    obj[parts[0]] = valueToSet;\n\n    return obj;\n  };\n\n  if (typeof valueToSet !== 'undefined' &&\n      typeof obj[parts[0]] === 'undefined') {\n    // We need to look ahead to check if array is appropriate\n    obj[parts[0]] = parts.length > 2 && numRe.test(parts[1]) ? [] : {};\n  };\n\n  let value = obj[parts[0]];\n\n  for (let i = 1; i < parts.length; i++) {\n    // Special case: We allow JSON Form syntax for arrays using empty brackets\n    // These will of course not work here so we exit if they are found.\n    if (parts[i] === '') {\n      return undefined;\n    };\n\n    if (typeof valueToSet !== 'undefined') {\n      if (i === parts.length - 1) {\n        // last step. Let's set the value\n        value[parts[i]] = valueToSet;\n        return valueToSet;\n      }\n      else {\n        // Make sure to create new objects on the way if they are not there.\n        // We need to look ahead to check if array is appropriate\n        let tmp = value[parts[i]];\n\n        if (typeof tmp === 'undefined' || tmp === null) {\n          tmp = numRe.test(parts[i + 1]) ? [] : {};\n          value[parts[i]] = tmp;\n        };\n\n        value = tmp;\n      };\n    }\n    else if (value) {\n      // Just get nex value.\n      value = value[parts[i]];\n    };\n  };\n\n  return value;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/select.js","/**\n * Traverse a schema, applying a function(schema,path) on every sub schema\n * i.e. every property of an object.\n */\nexport function traverseSchema(schema, fn, path, ignoreArrays) {\n  ignoreArrays = ignoreArrays === undefined ? true : ignoreArrays;\n\n  path = path || [];\n\n  const traverse = function(schemaObject: any, processorFunction: Function, pathArray: Array<string>) {\n    processorFunction(schemaObject, pathArray);\n    if (schemaObject.properties) {\n      Object.keys(schemaObject.properties).forEach((name) => {\n        const currentPath = pathArray.slice();\n        currentPath.push(name);\n        traverse(schemaObject.properties[name], processorFunction, currentPath);\n      });\n    }\n\n    // Only support type \"array\" which have a schemaObject as \"items\".\n    if (!ignoreArrays && schemaObject.items) {\n      const arrPath = pathArray.slice(); arrPath.push('');\n      traverse(schemaObject.items, processorFunction, arrPath);\n    }\n  };\n\n  traverse(schema, fn, path || []);\n}\n\nexport function traverseForm(form, fn) {\n  fn(form);\n  if (form.items) {\n    form.items.forEach((f) => {\n      traverseForm(f, fn);\n    });\n  }\n\n  if (form.tabs) {\n    form.tabs.forEach((tab) => {\n      if (tab.items) {\n        tab.items.forEach((f) => {\n          traverseForm(f, fn);\n        });\n      }\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/traverse.js","/*  Common code for validating a value against its form and schema definition */\nimport tv4 from 'tv4';\n\n/**\n * Validate a value against its form definition and schema.\n * The value should either be of proper type or a string, some type\n * coercion is applied.\n *\n * @param {Object} form A merged form definition, i.e. one with a schema.\n * @param {Any} value the value to validate.\n * @return {Object} a tv4js result object.\n */\nexport function validate(form, value) {\n  if (!form) {\n    return { valid: true };\n  };\n\n  let schema = form.schema;\n  if (!schema) {\n    return { valid: true };\n  };\n\n  // Input of type text and textareas will give us a viewValue of ''\n  // when empty, this is a valid value in a schema and does not count as something\n  // that breaks validation of 'required'. But for our own sanity an empty field should\n  // not validate if it's required.\n  if (value === '') {\n    value = undefined;\n  };\n\n  // Numbers fields will give a null value, which also means empty field\n  if (form.type === 'number' && value === null) {\n    value = undefined;\n  };\n\n  // Version 4 of JSON Schema has the required property not on the\n  // property itself but on the wrapping object. Since we like to test\n  // only this property we wrap it in a fake object.\n  let wrap = { type: 'object', 'properties': {}, required: undefined};\n  let propName = form.key[form.key.length - 1];\n  wrap.properties[propName] = schema;\n\n  if (form.required) {\n    wrap.required = [ propName ];\n  };\n\n  let valueWrap = {};\n  if (typeof value !== 'undefined') {\n    valueWrap[propName] = value;\n  };\n\n  return tv4.validateResult(valueWrap, wrap);\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/lib/validate.js","'use strict';\n\n;!function(undefined) {\n\tvar r = {\n\t\t'\\'': /\\\\\\'/g,\n\t\t'\"': /\\\\\\\"/g,\n\t};\n\n\tvar ObjectPath = {\n\t\tparse: function(str){\n\t\t\tif(typeof str !== 'string'){\n\t\t\t\tthrow new TypeError('ObjectPath.parse must be passed a string');\n\t\t\t}\n\n\t\t\tvar i = 0;\n\t\t\tvar parts = [];\n\t\t\tvar d, b, q, c;\n\t\t\twhile (i < str.length){\n\t\t\t\td = str.indexOf('.', i);\n\t\t\t\tb = str.indexOf('[', i);\n\n\t\t\t\t// we've reached the end\n\t\t\t\tif (d === -1 && b === -1){\n\t\t\t\t\tparts.push(str.slice(i, str.length));\n\t\t\t\t\ti = str.length;\n\t\t\t\t}\n\n\t\t\t\t// dots\n\t\t\t\telse if (b === -1 || (d !== -1 && d < b)) {\n\t\t\t\t\tparts.push(str.slice(i, d));\n\t\t\t\t\ti = d + 1;\n\t\t\t\t}\n\n\t\t\t\t// brackets\n\t\t\t\telse {\n\t\t\t\t\tif (b > i){\n\t\t\t\t\t\tparts.push(str.slice(i, b));\n\t\t\t\t\t\ti = b;\n\t\t\t\t\t}\n\t\t\t\t\tq = str.slice(b+1, b+2);\n\t\t\t\t\tif (q !== '\"' && q !=='\\'') {\n\t\t\t\t\t\tc = str.indexOf(']', b);\n\t\t\t\t\t\tif (c === -1) c = str.length;\n\t\t\t\t\t\tparts.push(str.slice(i + 1, c));\n\t\t\t\t\t\ti = (str.slice(c + 1, c + 2) === '.') ? c + 2 : c + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tc = str.indexOf(q+']', b);\n\t\t\t\t\t\tif (c === -1) c = str.length;\n\t\t\t\t\t\twhile (str.slice(c - 1, c) === '\\\\' && b < str.length){\n\t\t\t\t\t\t\tb++;\n\t\t\t\t\t\t\tc = str.indexOf(q+']', b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparts.push(str.slice(i + 2, c).replace(r[q], q));\n\t\t\t\t\t\ti = (str.slice(c + 2, c + 3) === '.') ? c + 3 : c + 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn parts;\n\t\t},\n\n\t\t// root === true : auto calculate root; must be dot-notation friendly\n\t\t// root String : the string to use as root\n\t\tstringify: function(arr, quote){\n\n\t\t\tif(!Array.isArray(arr))\n\t\t\t\tarr = [arr.toString()];\n\n\t\t\tquote = quote === '\"' ? '\"' : '\\'';\n\n\t\t\treturn arr.map(function(n){ return '[' + quote + (n.toString()).replace(new RegExp(quote, 'g'), '\\\\' + quote) + quote + ']'; }).join('');\n\t\t},\n\n\t\tnormalize: function(data, quote){\n\t\t\treturn ObjectPath.stringify(Array.isArray(data) ? data : ObjectPath.parse(data), quote);\n\t\t},\n\n\t\t// Angular\n\t\tregisterModule: function(angular) {\n\t\t\tangular.module('ObjectPath', []).provider('ObjectPath', function(){\n\t\t\t\tthis.parse = ObjectPath.parse;\n\t\t\t\tthis.stringify = ObjectPath.stringify;\n\t\t\t\tthis.normalize = ObjectPath.normalize;\n\t\t\t\tthis.$get = function(){\n\t\t\t\t\treturn ObjectPath;\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t};\n\n\t// AMD\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(function() {\n\t\t\treturn {\n\t\t\t\t\n\t\t\t\t// this is only namespaced for backwards compatibility when fixing issue #8\n\t\t\t\tObjectPath: ObjectPath,\n\t\t\t\t\n\t\t\t\t// export these as top-level functions\n\t\t\t\tparse: ObjectPath.parse,\n\t\t\t\tstringify: ObjectPath.stringify,\n\t\t\t\tnormalize: ObjectPath.normalize\n\t\t\t};\n\t\t});\n\t}\n\n\t// CommonJS\n\telse if (typeof exports === 'object') {\n\t\texports.ObjectPath = ObjectPath;\n\t}\n\n\t// Browser global\n\telse {\n\t\twindow.ObjectPath = ObjectPath;\n\t}\n\t\n}();\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/objectpath/lib/ObjectPath.js\n// module id = 11\n// module chunks = 0","/*\r\nAuthor: Geraint Luff and others\r\nYear: 2013\r\n\r\nThis code is released into the \"public domain\" by its author(s).  Anybody may use, alter and distribute the code without restriction.  The author makes no guarantees, and takes no liability of any kind for use of this code.\r\n\r\nIf you find a bug or make an improvement, it would be courteous to let the author know, but it is not compulsory.\r\n*/\r\n(function (global, factory) {\r\n  if (typeof define === 'function' && define.amd) {\r\n    // AMD. Register as an anonymous module.\r\n    define([], factory);\r\n  } else if (typeof module !== 'undefined' && module.exports){\r\n    // CommonJS. Define export.\r\n    module.exports = factory();\r\n  } else {\r\n    // Browser globals\r\n    global.tv4 = factory();\r\n  }\r\n}(this, function () {\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FObject%2Fkeys\r\nif (!Object.keys) {\r\n\tObject.keys = (function () {\r\n\t\tvar hasOwnProperty = Object.prototype.hasOwnProperty,\r\n\t\t\thasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),\r\n\t\t\tdontEnums = [\r\n\t\t\t\t'toString',\r\n\t\t\t\t'toLocaleString',\r\n\t\t\t\t'valueOf',\r\n\t\t\t\t'hasOwnProperty',\r\n\t\t\t\t'isPrototypeOf',\r\n\t\t\t\t'propertyIsEnumerable',\r\n\t\t\t\t'constructor'\r\n\t\t\t],\r\n\t\t\tdontEnumsLength = dontEnums.length;\r\n\r\n\t\treturn function (obj) {\r\n\t\t\tif (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {\r\n\t\t\t\tthrow new TypeError('Object.keys called on non-object');\r\n\t\t\t}\r\n\r\n\t\t\tvar result = [];\r\n\r\n\t\t\tfor (var prop in obj) {\r\n\t\t\t\tif (hasOwnProperty.call(obj, prop)) {\r\n\t\t\t\t\tresult.push(prop);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (hasDontEnumBug) {\r\n\t\t\t\tfor (var i=0; i < dontEnumsLength; i++) {\r\n\t\t\t\t\tif (hasOwnProperty.call(obj, dontEnums[i])) {\r\n\t\t\t\t\t\tresult.push(dontEnums[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t};\r\n\t})();\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create\r\nif (!Object.create) {\r\n\tObject.create = (function(){\r\n\t\tfunction F(){}\r\n\r\n\t\treturn function(o){\r\n\t\t\tif (arguments.length !== 1) {\r\n\t\t\t\tthrow new Error('Object.create implementation only accepts one parameter.');\r\n\t\t\t}\r\n\t\t\tF.prototype = o;\r\n\t\t\treturn new F();\r\n\t\t};\r\n\t})();\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FisArray\r\nif(!Array.isArray) {\r\n\tArray.isArray = function (vArg) {\r\n\t\treturn Object.prototype.toString.call(vArg) === \"[object Array]\";\r\n\t};\r\n}\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2FindexOf\r\nif (!Array.prototype.indexOf) {\r\n\tArray.prototype.indexOf = function (searchElement /*, fromIndex */ ) {\r\n\t\tif (this === null) {\r\n\t\t\tthrow new TypeError();\r\n\t\t}\r\n\t\tvar t = Object(this);\r\n\t\tvar len = t.length >>> 0;\r\n\r\n\t\tif (len === 0) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tvar n = 0;\r\n\t\tif (arguments.length > 1) {\r\n\t\t\tn = Number(arguments[1]);\r\n\t\t\tif (n !== n) { // shortcut for verifying if it's NaN\r\n\t\t\t\tn = 0;\r\n\t\t\t} else if (n !== 0 && n !== Infinity && n !== -Infinity) {\r\n\t\t\t\tn = (n > 0 || -1) * Math.floor(Math.abs(n));\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (n >= len) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\tvar k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\r\n\t\tfor (; k < len; k++) {\r\n\t\t\tif (k in t && t[k] === searchElement) {\r\n\t\t\t\treturn k;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t};\r\n}\r\n\r\n// Grungey Object.isFrozen hack\r\nif (!Object.isFrozen) {\r\n\tObject.isFrozen = function (obj) {\r\n\t\tvar key = \"tv4_test_frozen_key\";\r\n\t\twhile (obj.hasOwnProperty(key)) {\r\n\t\t\tkey += Math.random();\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tobj[key] = true;\r\n\t\t\tdelete obj[key];\r\n\t\t\treturn false;\r\n\t\t} catch (e) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t};\r\n}\r\n// Based on: https://github.com/geraintluff/uri-templates, but with all the de-substitution stuff removed\r\n\r\nvar uriTemplateGlobalModifiers = {\r\n\t\"+\": true,\r\n\t\"#\": true,\r\n\t\".\": true,\r\n\t\"/\": true,\r\n\t\";\": true,\r\n\t\"?\": true,\r\n\t\"&\": true\r\n};\r\nvar uriTemplateSuffices = {\r\n\t\"*\": true\r\n};\r\n\r\nfunction notReallyPercentEncode(string) {\r\n\treturn encodeURI(string).replace(/%25[0-9][0-9]/g, function (doubleEncoded) {\r\n\t\treturn \"%\" + doubleEncoded.substring(3);\r\n\t});\r\n}\r\n\r\nfunction uriTemplateSubstitution(spec) {\r\n\tvar modifier = \"\";\r\n\tif (uriTemplateGlobalModifiers[spec.charAt(0)]) {\r\n\t\tmodifier = spec.charAt(0);\r\n\t\tspec = spec.substring(1);\r\n\t}\r\n\tvar separator = \"\";\r\n\tvar prefix = \"\";\r\n\tvar shouldEscape = true;\r\n\tvar showVariables = false;\r\n\tvar trimEmptyString = false;\r\n\tif (modifier === '+') {\r\n\t\tshouldEscape = false;\r\n\t} else if (modifier === \".\") {\r\n\t\tprefix = \".\";\r\n\t\tseparator = \".\";\r\n\t} else if (modifier === \"/\") {\r\n\t\tprefix = \"/\";\r\n\t\tseparator = \"/\";\r\n\t} else if (modifier === '#') {\r\n\t\tprefix = \"#\";\r\n\t\tshouldEscape = false;\r\n\t} else if (modifier === ';') {\r\n\t\tprefix = \";\";\r\n\t\tseparator = \";\";\r\n\t\tshowVariables = true;\r\n\t\ttrimEmptyString = true;\r\n\t} else if (modifier === '?') {\r\n\t\tprefix = \"?\";\r\n\t\tseparator = \"&\";\r\n\t\tshowVariables = true;\r\n\t} else if (modifier === '&') {\r\n\t\tprefix = \"&\";\r\n\t\tseparator = \"&\";\r\n\t\tshowVariables = true;\r\n\t}\r\n\r\n\tvar varNames = [];\r\n\tvar varList = spec.split(\",\");\r\n\tvar varSpecs = [];\r\n\tvar varSpecMap = {};\r\n\tfor (var i = 0; i < varList.length; i++) {\r\n\t\tvar varName = varList[i];\r\n\t\tvar truncate = null;\r\n\t\tif (varName.indexOf(\":\") !== -1) {\r\n\t\t\tvar parts = varName.split(\":\");\r\n\t\t\tvarName = parts[0];\r\n\t\t\ttruncate = parseInt(parts[1], 10);\r\n\t\t}\r\n\t\tvar suffices = {};\r\n\t\twhile (uriTemplateSuffices[varName.charAt(varName.length - 1)]) {\r\n\t\t\tsuffices[varName.charAt(varName.length - 1)] = true;\r\n\t\t\tvarName = varName.substring(0, varName.length - 1);\r\n\t\t}\r\n\t\tvar varSpec = {\r\n\t\t\ttruncate: truncate,\r\n\t\t\tname: varName,\r\n\t\t\tsuffices: suffices\r\n\t\t};\r\n\t\tvarSpecs.push(varSpec);\r\n\t\tvarSpecMap[varName] = varSpec;\r\n\t\tvarNames.push(varName);\r\n\t}\r\n\tvar subFunction = function (valueFunction) {\r\n\t\tvar result = \"\";\r\n\t\tvar startIndex = 0;\r\n\t\tfor (var i = 0; i < varSpecs.length; i++) {\r\n\t\t\tvar varSpec = varSpecs[i];\r\n\t\t\tvar value = valueFunction(varSpec.name);\r\n\t\t\tif (value === null || value === undefined || (Array.isArray(value) && value.length === 0) || (typeof value === 'object' && Object.keys(value).length === 0)) {\r\n\t\t\t\tstartIndex++;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (i === startIndex) {\r\n\t\t\t\tresult += prefix;\r\n\t\t\t} else {\r\n\t\t\t\tresult += (separator || \",\");\r\n\t\t\t}\r\n\t\t\tif (Array.isArray(value)) {\r\n\t\t\t\tif (showVariables) {\r\n\t\t\t\t\tresult += varSpec.name + \"=\";\r\n\t\t\t\t}\r\n\t\t\t\tfor (var j = 0; j < value.length; j++) {\r\n\t\t\t\t\tif (j > 0) {\r\n\t\t\t\t\t\tresult += varSpec.suffices['*'] ? (separator || \",\") : \",\";\r\n\t\t\t\t\t\tif (varSpec.suffices['*'] && showVariables) {\r\n\t\t\t\t\t\t\tresult += varSpec.name + \"=\";\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(value[j]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[j]);\r\n\t\t\t\t}\r\n\t\t\t} else if (typeof value === \"object\") {\r\n\t\t\t\tif (showVariables && !varSpec.suffices['*']) {\r\n\t\t\t\t\tresult += varSpec.name + \"=\";\r\n\t\t\t\t}\r\n\t\t\t\tvar first = true;\r\n\t\t\t\tfor (var key in value) {\r\n\t\t\t\t\tif (!first) {\r\n\t\t\t\t\t\tresult += varSpec.suffices['*'] ? (separator || \",\") : \",\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfirst = false;\r\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(key).replace(/!/g, \"%21\") : notReallyPercentEncode(key);\r\n\t\t\t\t\tresult += varSpec.suffices['*'] ? '=' : \",\";\r\n\t\t\t\t\tresult += shouldEscape ? encodeURIComponent(value[key]).replace(/!/g, \"%21\") : notReallyPercentEncode(value[key]);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (showVariables) {\r\n\t\t\t\t\tresult += varSpec.name;\r\n\t\t\t\t\tif (!trimEmptyString || value !== \"\") {\r\n\t\t\t\t\t\tresult += \"=\";\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (varSpec.truncate != null) {\r\n\t\t\t\t\tvalue = value.substring(0, varSpec.truncate);\r\n\t\t\t\t}\r\n\t\t\t\tresult += shouldEscape ? encodeURIComponent(value).replace(/!/g, \"%21\"): notReallyPercentEncode(value);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\tsubFunction.varNames = varNames;\r\n\treturn {\r\n\t\tprefix: prefix,\r\n\t\tsubstitution: subFunction\r\n\t};\r\n}\r\n\r\nfunction UriTemplate(template) {\r\n\tif (!(this instanceof UriTemplate)) {\r\n\t\treturn new UriTemplate(template);\r\n\t}\r\n\tvar parts = template.split(\"{\");\r\n\tvar textParts = [parts.shift()];\r\n\tvar prefixes = [];\r\n\tvar substitutions = [];\r\n\tvar varNames = [];\r\n\twhile (parts.length > 0) {\r\n\t\tvar part = parts.shift();\r\n\t\tvar spec = part.split(\"}\")[0];\r\n\t\tvar remainder = part.substring(spec.length + 1);\r\n\t\tvar funcs = uriTemplateSubstitution(spec);\r\n\t\tsubstitutions.push(funcs.substitution);\r\n\t\tprefixes.push(funcs.prefix);\r\n\t\ttextParts.push(remainder);\r\n\t\tvarNames = varNames.concat(funcs.substitution.varNames);\r\n\t}\r\n\tthis.fill = function (valueFunction) {\r\n\t\tvar result = textParts[0];\r\n\t\tfor (var i = 0; i < substitutions.length; i++) {\r\n\t\t\tvar substitution = substitutions[i];\r\n\t\t\tresult += substitution(valueFunction);\r\n\t\t\tresult += textParts[i + 1];\r\n\t\t}\r\n\t\treturn result;\r\n\t};\r\n\tthis.varNames = varNames;\r\n\tthis.template = template;\r\n}\r\nUriTemplate.prototype = {\r\n\ttoString: function () {\r\n\t\treturn this.template;\r\n\t},\r\n\tfillFromObject: function (obj) {\r\n\t\treturn this.fill(function (varName) {\r\n\t\t\treturn obj[varName];\r\n\t\t});\r\n\t}\r\n};\r\nvar ValidatorContext = function ValidatorContext(parent, collectMultiple, errorReporter, checkRecursive, trackUnknownProperties) {\r\n\tthis.missing = [];\r\n\tthis.missingMap = {};\r\n\tthis.formatValidators = parent ? Object.create(parent.formatValidators) : {};\r\n\tthis.schemas = parent ? Object.create(parent.schemas) : {};\r\n\tthis.collectMultiple = collectMultiple;\r\n\tthis.errors = [];\r\n\tthis.handleError = collectMultiple ? this.collectError : this.returnError;\r\n\tif (checkRecursive) {\r\n\t\tthis.checkRecursive = true;\r\n\t\tthis.scanned = [];\r\n\t\tthis.scannedFrozen = [];\r\n\t\tthis.scannedFrozenSchemas = [];\r\n\t\tthis.scannedFrozenValidationErrors = [];\r\n\t\tthis.validatedSchemasKey = 'tv4_validation_id';\r\n\t\tthis.validationErrorsKey = 'tv4_validation_errors_id';\r\n\t}\r\n\tif (trackUnknownProperties) {\r\n\t\tthis.trackUnknownProperties = true;\r\n\t\tthis.knownPropertyPaths = {};\r\n\t\tthis.unknownPropertyPaths = {};\r\n\t}\r\n\tthis.errorReporter = errorReporter || defaultErrorReporter('en');\r\n\tif (typeof this.errorReporter === 'string') {\r\n\t\tthrow new Error('debug');\r\n\t}\r\n\tthis.definedKeywords = {};\r\n\tif (parent) {\r\n\t\tfor (var key in parent.definedKeywords) {\r\n\t\t\tthis.definedKeywords[key] = parent.definedKeywords[key].slice(0);\r\n\t\t}\r\n\t}\r\n};\r\nValidatorContext.prototype.defineKeyword = function (keyword, keywordFunction) {\r\n\tthis.definedKeywords[keyword] = this.definedKeywords[keyword] || [];\r\n\tthis.definedKeywords[keyword].push(keywordFunction);\r\n};\r\nValidatorContext.prototype.createError = function (code, messageParams, dataPath, schemaPath, subErrors, data, schema) {\r\n\tvar error = new ValidationError(code, messageParams, dataPath, schemaPath, subErrors);\r\n\terror.message = this.errorReporter(error, data, schema);\r\n\treturn error;\r\n};\r\nValidatorContext.prototype.returnError = function (error) {\r\n\treturn error;\r\n};\r\nValidatorContext.prototype.collectError = function (error) {\r\n\tif (error) {\r\n\t\tthis.errors.push(error);\r\n\t}\r\n\treturn null;\r\n};\r\nValidatorContext.prototype.prefixErrors = function (startIndex, dataPath, schemaPath) {\r\n\tfor (var i = startIndex; i < this.errors.length; i++) {\r\n\t\tthis.errors[i] = this.errors[i].prefixWith(dataPath, schemaPath);\r\n\t}\r\n\treturn this;\r\n};\r\nValidatorContext.prototype.banUnknownProperties = function (data, schema) {\r\n\tfor (var unknownPath in this.unknownPropertyPaths) {\r\n\t\tvar error = this.createError(ErrorCodes.UNKNOWN_PROPERTY, {path: unknownPath}, unknownPath, \"\", null, data, schema);\r\n\t\tvar result = this.handleError(error);\r\n\t\tif (result) {\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.addFormat = function (format, validator) {\r\n\tif (typeof format === 'object') {\r\n\t\tfor (var key in format) {\r\n\t\t\tthis.addFormat(key, format[key]);\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\tthis.formatValidators[format] = validator;\r\n};\r\nValidatorContext.prototype.resolveRefs = function (schema, urlHistory) {\r\n\tif (schema['$ref'] !== undefined) {\r\n\t\turlHistory = urlHistory || {};\r\n\t\tif (urlHistory[schema['$ref']]) {\r\n\t\t\treturn this.createError(ErrorCodes.CIRCULAR_REFERENCE, {urls: Object.keys(urlHistory).join(', ')}, '', '', null, undefined, schema);\r\n\t\t}\r\n\t\turlHistory[schema['$ref']] = true;\r\n\t\tschema = this.getSchema(schema['$ref'], urlHistory);\r\n\t}\r\n\treturn schema;\r\n};\r\nValidatorContext.prototype.getSchema = function (url, urlHistory) {\r\n\tvar schema;\r\n\tif (this.schemas[url] !== undefined) {\r\n\t\tschema = this.schemas[url];\r\n\t\treturn this.resolveRefs(schema, urlHistory);\r\n\t}\r\n\tvar baseUrl = url;\r\n\tvar fragment = \"\";\r\n\tif (url.indexOf('#') !== -1) {\r\n\t\tfragment = url.substring(url.indexOf(\"#\") + 1);\r\n\t\tbaseUrl = url.substring(0, url.indexOf(\"#\"));\r\n\t}\r\n\tif (typeof this.schemas[baseUrl] === 'object') {\r\n\t\tschema = this.schemas[baseUrl];\r\n\t\tvar pointerPath = decodeURIComponent(fragment);\r\n\t\tif (pointerPath === \"\") {\r\n\t\t\treturn this.resolveRefs(schema, urlHistory);\r\n\t\t} else if (pointerPath.charAt(0) !== \"/\") {\r\n\t\t\treturn undefined;\r\n\t\t}\r\n\t\tvar parts = pointerPath.split(\"/\").slice(1);\r\n\t\tfor (var i = 0; i < parts.length; i++) {\r\n\t\t\tvar component = parts[i].replace(/~1/g, \"/\").replace(/~0/g, \"~\");\r\n\t\t\tif (schema[component] === undefined) {\r\n\t\t\t\tschema = undefined;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tschema = schema[component];\r\n\t\t}\r\n\t\tif (schema !== undefined) {\r\n\t\t\treturn this.resolveRefs(schema, urlHistory);\r\n\t\t}\r\n\t}\r\n\tif (this.missing[baseUrl] === undefined) {\r\n\t\tthis.missing.push(baseUrl);\r\n\t\tthis.missing[baseUrl] = baseUrl;\r\n\t\tthis.missingMap[baseUrl] = baseUrl;\r\n\t}\r\n};\r\nValidatorContext.prototype.searchSchemas = function (schema, url) {\r\n\tif (Array.isArray(schema)) {\r\n\t\tfor (var i = 0; i < schema.length; i++) {\r\n\t\t\tthis.searchSchemas(schema[i], url);\r\n\t\t}\r\n\t} else if (schema && typeof schema === \"object\") {\r\n\t\tif (typeof schema.id === \"string\") {\r\n\t\t\tif (isTrustedUrl(url, schema.id)) {\r\n\t\t\t\tif (this.schemas[schema.id] === undefined) {\r\n\t\t\t\t\tthis.schemas[schema.id] = schema;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor (var key in schema) {\r\n\t\t\tif (key !== \"enum\") {\r\n\t\t\t\tif (typeof schema[key] === \"object\") {\r\n\t\t\t\t\tthis.searchSchemas(schema[key], url);\r\n\t\t\t\t} else if (key === \"$ref\") {\r\n\t\t\t\t\tvar uri = getDocumentUri(schema[key]);\r\n\t\t\t\t\tif (uri && this.schemas[uri] === undefined && this.missingMap[uri] === undefined) {\r\n\t\t\t\t\t\tthis.missingMap[uri] = uri;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\nValidatorContext.prototype.addSchema = function (url, schema) {\r\n\t//overload\r\n\tif (typeof url !== 'string' || typeof schema === 'undefined') {\r\n\t\tif (typeof url === 'object' && typeof url.id === 'string') {\r\n\t\t\tschema = url;\r\n\t\t\turl = schema.id;\r\n\t\t}\r\n\t\telse {\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (url === getDocumentUri(url) + \"#\") {\r\n\t\t// Remove empty fragment\r\n\t\turl = getDocumentUri(url);\r\n\t}\r\n\tthis.schemas[url] = schema;\r\n\tdelete this.missingMap[url];\r\n\tnormSchema(schema, url);\r\n\tthis.searchSchemas(schema, url);\r\n};\r\n\r\nValidatorContext.prototype.getSchemaMap = function () {\r\n\tvar map = {};\r\n\tfor (var key in this.schemas) {\r\n\t\tmap[key] = this.schemas[key];\r\n\t}\r\n\treturn map;\r\n};\r\n\r\nValidatorContext.prototype.getSchemaUris = function (filterRegExp) {\r\n\tvar list = [];\r\n\tfor (var key in this.schemas) {\r\n\t\tif (!filterRegExp || filterRegExp.test(key)) {\r\n\t\t\tlist.push(key);\r\n\t\t}\r\n\t}\r\n\treturn list;\r\n};\r\n\r\nValidatorContext.prototype.getMissingUris = function (filterRegExp) {\r\n\tvar list = [];\r\n\tfor (var key in this.missingMap) {\r\n\t\tif (!filterRegExp || filterRegExp.test(key)) {\r\n\t\t\tlist.push(key);\r\n\t\t}\r\n\t}\r\n\treturn list;\r\n};\r\n\r\nValidatorContext.prototype.dropSchemas = function () {\r\n\tthis.schemas = {};\r\n\tthis.reset();\r\n};\r\nValidatorContext.prototype.reset = function () {\r\n\tthis.missing = [];\r\n\tthis.missingMap = {};\r\n\tthis.errors = [];\r\n};\r\n\r\nValidatorContext.prototype.validateAll = function (data, schema, dataPathParts, schemaPathParts, dataPointerPath) {\r\n\tvar topLevel;\r\n\tschema = this.resolveRefs(schema);\r\n\tif (!schema) {\r\n\t\treturn null;\r\n\t} else if (schema instanceof ValidationError) {\r\n\t\tthis.errors.push(schema);\r\n\t\treturn schema;\r\n\t}\r\n\r\n\tvar startErrorCount = this.errors.length;\r\n\tvar frozenIndex, scannedFrozenSchemaIndex = null, scannedSchemasIndex = null;\r\n\tif (this.checkRecursive && data && typeof data === 'object') {\r\n\t\ttopLevel = !this.scanned.length;\r\n\t\tif (data[this.validatedSchemasKey]) {\r\n\t\t\tvar schemaIndex = data[this.validatedSchemasKey].indexOf(schema);\r\n\t\t\tif (schemaIndex !== -1) {\r\n\t\t\t\tthis.errors = this.errors.concat(data[this.validationErrorsKey][schemaIndex]);\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (Object.isFrozen(data)) {\r\n\t\t\tfrozenIndex = this.scannedFrozen.indexOf(data);\r\n\t\t\tif (frozenIndex !== -1) {\r\n\t\t\t\tvar frozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].indexOf(schema);\r\n\t\t\t\tif (frozenSchemaIndex !== -1) {\r\n\t\t\t\t\tthis.errors = this.errors.concat(this.scannedFrozenValidationErrors[frozenIndex][frozenSchemaIndex]);\r\n\t\t\t\t\treturn null;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tthis.scanned.push(data);\r\n\t\tif (Object.isFrozen(data)) {\r\n\t\t\tif (frozenIndex === -1) {\r\n\t\t\t\tfrozenIndex = this.scannedFrozen.length;\r\n\t\t\t\tthis.scannedFrozen.push(data);\r\n\t\t\t\tthis.scannedFrozenSchemas.push([]);\r\n\t\t\t}\r\n\t\t\tscannedFrozenSchemaIndex = this.scannedFrozenSchemas[frozenIndex].length;\r\n\t\t\tthis.scannedFrozenSchemas[frozenIndex][scannedFrozenSchemaIndex] = schema;\r\n\t\t\tthis.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = [];\r\n\t\t} else {\r\n\t\t\tif (!data[this.validatedSchemasKey]) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tObject.defineProperty(data, this.validatedSchemasKey, {\r\n\t\t\t\t\t\tvalue: [],\r\n\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t});\r\n\t\t\t\t\tObject.defineProperty(data, this.validationErrorsKey, {\r\n\t\t\t\t\t\tvalue: [],\r\n\t\t\t\t\t\tconfigurable: true\r\n\t\t\t\t\t});\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\t//IE 7/8 workaround\r\n\t\t\t\t\tdata[this.validatedSchemasKey] = [];\r\n\t\t\t\t\tdata[this.validationErrorsKey] = [];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tscannedSchemasIndex = data[this.validatedSchemasKey].length;\r\n\t\t\tdata[this.validatedSchemasKey][scannedSchemasIndex] = schema;\r\n\t\t\tdata[this.validationErrorsKey][scannedSchemasIndex] = [];\r\n\t\t}\r\n\t}\r\n\r\n\tvar errorCount = this.errors.length;\r\n\tvar error = this.validateBasic(data, schema, dataPointerPath)\r\n\t\t|| this.validateNumeric(data, schema, dataPointerPath)\r\n\t\t|| this.validateString(data, schema, dataPointerPath)\r\n\t\t|| this.validateArray(data, schema, dataPointerPath)\r\n\t\t|| this.validateObject(data, schema, dataPointerPath)\r\n\t\t|| this.validateCombinations(data, schema, dataPointerPath)\r\n\t\t|| this.validateHypermedia(data, schema, dataPointerPath)\r\n\t\t|| this.validateFormat(data, schema, dataPointerPath)\r\n\t\t|| this.validateDefinedKeywords(data, schema, dataPointerPath)\r\n\t\t|| null;\r\n\r\n\tif (topLevel) {\r\n\t\twhile (this.scanned.length) {\r\n\t\t\tvar item = this.scanned.pop();\r\n\t\t\tdelete item[this.validatedSchemasKey];\r\n\t\t}\r\n\t\tthis.scannedFrozen = [];\r\n\t\tthis.scannedFrozenSchemas = [];\r\n\t}\r\n\r\n\tif (error || errorCount !== this.errors.length) {\r\n\t\twhile ((dataPathParts && dataPathParts.length) || (schemaPathParts && schemaPathParts.length)) {\r\n\t\t\tvar dataPart = (dataPathParts && dataPathParts.length) ? \"\" + dataPathParts.pop() : null;\r\n\t\t\tvar schemaPart = (schemaPathParts && schemaPathParts.length) ? \"\" + schemaPathParts.pop() : null;\r\n\t\t\tif (error) {\r\n\t\t\t\terror = error.prefixWith(dataPart, schemaPart);\r\n\t\t\t}\r\n\t\t\tthis.prefixErrors(errorCount, dataPart, schemaPart);\r\n\t\t}\r\n\t}\r\n\r\n\tif (scannedFrozenSchemaIndex !== null) {\r\n\t\tthis.scannedFrozenValidationErrors[frozenIndex][scannedFrozenSchemaIndex] = this.errors.slice(startErrorCount);\r\n\t} else if (scannedSchemasIndex !== null) {\r\n\t\tdata[this.validationErrorsKey][scannedSchemasIndex] = this.errors.slice(startErrorCount);\r\n\t}\r\n\r\n\treturn this.handleError(error);\r\n};\r\nValidatorContext.prototype.validateFormat = function (data, schema) {\r\n\tif (typeof schema.format !== 'string' || !this.formatValidators[schema.format]) {\r\n\t\treturn null;\r\n\t}\r\n\tvar errorMessage = this.formatValidators[schema.format].call(null, data, schema);\r\n\tif (typeof errorMessage === 'string' || typeof errorMessage === 'number') {\r\n\t\treturn this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage}, '', '/format', null, data, schema);\r\n\t} else if (errorMessage && typeof errorMessage === 'object') {\r\n\t\treturn this.createError(ErrorCodes.FORMAT_CUSTOM, {message: errorMessage.message || \"?\"}, errorMessage.dataPath || '', errorMessage.schemaPath || \"/format\", null, data, schema);\r\n\t}\r\n\treturn null;\r\n};\r\nValidatorContext.prototype.validateDefinedKeywords = function (data, schema, dataPointerPath) {\r\n\tfor (var key in this.definedKeywords) {\r\n\t\tif (typeof schema[key] === 'undefined') {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar validationFunctions = this.definedKeywords[key];\r\n\t\tfor (var i = 0; i < validationFunctions.length; i++) {\r\n\t\t\tvar func = validationFunctions[i];\r\n\t\t\tvar result = func(data, schema[key], schema, dataPointerPath);\r\n\t\t\tif (typeof result === 'string' || typeof result === 'number') {\r\n\t\t\t\treturn this.createError(ErrorCodes.KEYWORD_CUSTOM, {key: key, message: result}, '', '', null, data, schema).prefixWith(null, key);\r\n\t\t\t} else if (result && typeof result === 'object') {\r\n\t\t\t\tvar code = result.code;\r\n\t\t\t\tif (typeof code === 'string') {\r\n\t\t\t\t\tif (!ErrorCodes[code]) {\r\n\t\t\t\t\t\tthrow new Error('Undefined error code (use defineError): ' + code);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcode = ErrorCodes[code];\r\n\t\t\t\t} else if (typeof code !== 'number') {\r\n\t\t\t\t\tcode = ErrorCodes.KEYWORD_CUSTOM;\r\n\t\t\t\t}\r\n\t\t\t\tvar messageParams = (typeof result.message === 'object') ? result.message : {key: key, message: result.message || \"?\"};\r\n\t\t\t\tvar schemaPath = result.schemaPath || (\"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1'));\r\n\t\t\t\treturn this.createError(code, messageParams, result.dataPath || null, schemaPath, null, data, schema);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nfunction recursiveCompare(A, B) {\r\n\tif (A === B) {\r\n\t\treturn true;\r\n\t}\r\n\tif (A && B && typeof A === \"object\" && typeof B === \"object\") {\r\n\t\tif (Array.isArray(A) !== Array.isArray(B)) {\r\n\t\t\treturn false;\r\n\t\t} else if (Array.isArray(A)) {\r\n\t\t\tif (A.length !== B.length) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tfor (var i = 0; i < A.length; i++) {\r\n\t\t\t\tif (!recursiveCompare(A[i], B[i])) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar key;\r\n\t\t\tfor (key in A) {\r\n\t\t\t\tif (B[key] === undefined && A[key] !== undefined) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (key in B) {\r\n\t\t\t\tif (A[key] === undefined && B[key] !== undefined) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (key in A) {\r\n\t\t\t\tif (!recursiveCompare(A[key], B[key])) {\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nValidatorContext.prototype.validateBasic = function validateBasic(data, schema, dataPointerPath) {\r\n\tvar error;\r\n\tif (error = this.validateType(data, schema, dataPointerPath)) {\r\n\t\treturn error.prefixWith(null, \"type\");\r\n\t}\r\n\tif (error = this.validateEnum(data, schema, dataPointerPath)) {\r\n\t\treturn error.prefixWith(null, \"type\");\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateType = function validateType(data, schema) {\r\n\tif (schema.type === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\tvar dataType = typeof data;\r\n\tif (data === null) {\r\n\t\tdataType = \"null\";\r\n\t} else if (Array.isArray(data)) {\r\n\t\tdataType = \"array\";\r\n\t}\r\n\tvar allowedTypes = schema.type;\r\n\tif (!Array.isArray(allowedTypes)) {\r\n\t\tallowedTypes = [allowedTypes];\r\n\t}\r\n\r\n\tfor (var i = 0; i < allowedTypes.length; i++) {\r\n\t\tvar type = allowedTypes[i];\r\n\t\tif (type === dataType || (type === \"integer\" && dataType === \"number\" && (data % 1 === 0))) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\treturn this.createError(ErrorCodes.INVALID_TYPE, {type: dataType, expected: allowedTypes.join(\"/\")}, '', '', null, data, schema);\r\n};\r\n\r\nValidatorContext.prototype.validateEnum = function validateEnum(data, schema) {\r\n\tif (schema[\"enum\"] === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\tfor (var i = 0; i < schema[\"enum\"].length; i++) {\r\n\t\tvar enumVal = schema[\"enum\"][i];\r\n\t\tif (recursiveCompare(data, enumVal)) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\treturn this.createError(ErrorCodes.ENUM_MISMATCH, {value: (typeof JSON !== 'undefined') ? JSON.stringify(data) : data}, '', '', null, data, schema);\r\n};\r\n\r\nValidatorContext.prototype.validateNumeric = function validateNumeric(data, schema, dataPointerPath) {\r\n\treturn this.validateMultipleOf(data, schema, dataPointerPath)\r\n\t\t|| this.validateMinMax(data, schema, dataPointerPath)\r\n\t\t|| this.validateNaN(data, schema, dataPointerPath)\r\n\t\t|| null;\r\n};\r\n\r\nvar CLOSE_ENOUGH_LOW = Math.pow(2, -51);\r\nvar CLOSE_ENOUGH_HIGH = 1 - CLOSE_ENOUGH_LOW;\r\nValidatorContext.prototype.validateMultipleOf = function validateMultipleOf(data, schema) {\r\n\tvar multipleOf = schema.multipleOf || schema.divisibleBy;\r\n\tif (multipleOf === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\tif (typeof data === \"number\") {\r\n\t\tvar remainder = (data/multipleOf)%1;\r\n\t\tif (remainder >= CLOSE_ENOUGH_LOW && remainder < CLOSE_ENOUGH_HIGH) {\r\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MULTIPLE_OF, {value: data, multipleOf: multipleOf}, '', '', null, data, schema);\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateMinMax = function validateMinMax(data, schema) {\r\n\tif (typeof data !== \"number\") {\r\n\t\treturn null;\r\n\t}\r\n\tif (schema.minimum !== undefined) {\r\n\t\tif (data < schema.minimum) {\r\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MINIMUM, {value: data, minimum: schema.minimum}, '', '/minimum', null, data, schema);\r\n\t\t}\r\n\t\tif (schema.exclusiveMinimum && data === schema.minimum) {\r\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MINIMUM_EXCLUSIVE, {value: data, minimum: schema.minimum}, '', '/exclusiveMinimum', null, data, schema);\r\n\t\t}\r\n\t}\r\n\tif (schema.maximum !== undefined) {\r\n\t\tif (data > schema.maximum) {\r\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MAXIMUM, {value: data, maximum: schema.maximum}, '', '/maximum', null, data, schema);\r\n\t\t}\r\n\t\tif (schema.exclusiveMaximum && data === schema.maximum) {\r\n\t\t\treturn this.createError(ErrorCodes.NUMBER_MAXIMUM_EXCLUSIVE, {value: data, maximum: schema.maximum}, '', '/exclusiveMaximum', null, data, schema);\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateNaN = function validateNaN(data, schema) {\r\n\tif (typeof data !== \"number\") {\r\n\t\treturn null;\r\n\t}\r\n\tif (isNaN(data) === true || data === Infinity || data === -Infinity) {\r\n\t\treturn this.createError(ErrorCodes.NUMBER_NOT_A_NUMBER, {value: data}, '', '/type', null, data, schema);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateString = function validateString(data, schema, dataPointerPath) {\r\n\treturn this.validateStringLength(data, schema, dataPointerPath)\r\n\t\t|| this.validateStringPattern(data, schema, dataPointerPath)\r\n\t\t|| null;\r\n};\r\n\r\nValidatorContext.prototype.validateStringLength = function validateStringLength(data, schema) {\r\n\tif (typeof data !== \"string\") {\r\n\t\treturn null;\r\n\t}\r\n\tif (schema.minLength !== undefined) {\r\n\t\tif (data.length < schema.minLength) {\r\n\t\t\treturn this.createError(ErrorCodes.STRING_LENGTH_SHORT, {length: data.length, minimum: schema.minLength}, '', '/minLength', null, data, schema);\r\n\t\t}\r\n\t}\r\n\tif (schema.maxLength !== undefined) {\r\n\t\tif (data.length > schema.maxLength) {\r\n\t\t\treturn this.createError(ErrorCodes.STRING_LENGTH_LONG, {length: data.length, maximum: schema.maxLength}, '', '/maxLength', null, data, schema);\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateStringPattern = function validateStringPattern(data, schema) {\r\n\tif (typeof data !== \"string\" || (typeof schema.pattern !== \"string\" && !(schema.pattern instanceof RegExp))) {\r\n\t\treturn null;\r\n\t}\r\n\tvar regexp;\r\n\tif (schema.pattern instanceof RegExp) {\r\n\t  regexp = schema.pattern;\r\n\t}\r\n\telse {\r\n\t  var body, flags = '';\r\n\t  // Check for regular expression literals\r\n\t  // @see http://www.ecma-international.org/ecma-262/5.1/#sec-7.8.5\r\n\t  var literal = schema.pattern.match(/^\\/(.+)\\/([img]*)$/);\r\n\t  if (literal) {\r\n\t    body = literal[1];\r\n\t    flags = literal[2];\r\n\t  }\r\n\t  else {\r\n\t    body = schema.pattern;\r\n\t  }\r\n\t  regexp = new RegExp(body, flags);\r\n\t}\r\n\tif (!regexp.test(data)) {\r\n\t\treturn this.createError(ErrorCodes.STRING_PATTERN, {pattern: schema.pattern}, '', '/pattern', null, data, schema);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateArray = function validateArray(data, schema, dataPointerPath) {\r\n\tif (!Array.isArray(data)) {\r\n\t\treturn null;\r\n\t}\r\n\treturn this.validateArrayLength(data, schema, dataPointerPath)\r\n\t\t|| this.validateArrayUniqueItems(data, schema, dataPointerPath)\r\n\t\t|| this.validateArrayItems(data, schema, dataPointerPath)\r\n\t\t|| null;\r\n};\r\n\r\nValidatorContext.prototype.validateArrayLength = function validateArrayLength(data, schema) {\r\n\tvar error;\r\n\tif (schema.minItems !== undefined) {\r\n\t\tif (data.length < schema.minItems) {\r\n\t\t\terror = this.createError(ErrorCodes.ARRAY_LENGTH_SHORT, {length: data.length, minimum: schema.minItems}, '', '/minItems', null, data, schema);\r\n\t\t\tif (this.handleError(error)) {\r\n\t\t\t\treturn error;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (schema.maxItems !== undefined) {\r\n\t\tif (data.length > schema.maxItems) {\r\n\t\t\terror = this.createError(ErrorCodes.ARRAY_LENGTH_LONG, {length: data.length, maximum: schema.maxItems}, '', '/maxItems', null, data, schema);\r\n\t\t\tif (this.handleError(error)) {\r\n\t\t\t\treturn error;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateArrayUniqueItems = function validateArrayUniqueItems(data, schema) {\r\n\tif (schema.uniqueItems) {\r\n\t\tfor (var i = 0; i < data.length; i++) {\r\n\t\t\tfor (var j = i + 1; j < data.length; j++) {\r\n\t\t\t\tif (recursiveCompare(data[i], data[j])) {\r\n\t\t\t\t\tvar error = this.createError(ErrorCodes.ARRAY_UNIQUE, {match1: i, match2: j}, '', '/uniqueItems', null, data, schema);\r\n\t\t\t\t\tif (this.handleError(error)) {\r\n\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateArrayItems = function validateArrayItems(data, schema, dataPointerPath) {\r\n\tif (schema.items === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\tvar error, i;\r\n\tif (Array.isArray(schema.items)) {\r\n\t\tfor (i = 0; i < data.length; i++) {\r\n\t\t\tif (i < schema.items.length) {\r\n\t\t\t\tif (error = this.validateAll(data[i], schema.items[i], [i], [\"items\", i], dataPointerPath + \"/\" + i)) {\r\n\t\t\t\t\treturn error;\r\n\t\t\t\t}\r\n\t\t\t} else if (schema.additionalItems !== undefined) {\r\n\t\t\t\tif (typeof schema.additionalItems === \"boolean\") {\r\n\t\t\t\t\tif (!schema.additionalItems) {\r\n\t\t\t\t\t\terror = (this.createError(ErrorCodes.ARRAY_ADDITIONAL_ITEMS, {}, '/' + i, '/additionalItems', null, data, schema));\r\n\t\t\t\t\t\tif (this.handleError(error)) {\r\n\t\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (error = this.validateAll(data[i], schema.additionalItems, [i], [\"additionalItems\"], dataPointerPath + \"/\" + i)) {\r\n\t\t\t\t\treturn error;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tfor (i = 0; i < data.length; i++) {\r\n\t\t\tif (error = this.validateAll(data[i], schema.items, [i], [\"items\"], dataPointerPath + \"/\" + i)) {\r\n\t\t\t\treturn error;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateObject = function validateObject(data, schema, dataPointerPath) {\r\n\tif (typeof data !== \"object\" || data === null || Array.isArray(data)) {\r\n\t\treturn null;\r\n\t}\r\n\treturn this.validateObjectMinMaxProperties(data, schema, dataPointerPath)\r\n\t\t|| this.validateObjectRequiredProperties(data, schema, dataPointerPath)\r\n\t\t|| this.validateObjectProperties(data, schema, dataPointerPath)\r\n\t\t|| this.validateObjectDependencies(data, schema, dataPointerPath)\r\n\t\t|| null;\r\n};\r\n\r\nValidatorContext.prototype.validateObjectMinMaxProperties = function validateObjectMinMaxProperties(data, schema) {\r\n\tvar keys = Object.keys(data);\r\n\tvar error;\r\n\tif (schema.minProperties !== undefined) {\r\n\t\tif (keys.length < schema.minProperties) {\r\n\t\t\terror = this.createError(ErrorCodes.OBJECT_PROPERTIES_MINIMUM, {propertyCount: keys.length, minimum: schema.minProperties}, '', '/minProperties', null, data, schema);\r\n\t\t\tif (this.handleError(error)) {\r\n\t\t\t\treturn error;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (schema.maxProperties !== undefined) {\r\n\t\tif (keys.length > schema.maxProperties) {\r\n\t\t\terror = this.createError(ErrorCodes.OBJECT_PROPERTIES_MAXIMUM, {propertyCount: keys.length, maximum: schema.maxProperties}, '', '/maxProperties', null, data, schema);\r\n\t\t\tif (this.handleError(error)) {\r\n\t\t\t\treturn error;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateObjectRequiredProperties = function validateObjectRequiredProperties(data, schema) {\r\n\tif (schema.required !== undefined) {\r\n\t\tfor (var i = 0; i < schema.required.length; i++) {\r\n\t\t\tvar key = schema.required[i];\r\n\t\t\tif (data[key] === undefined) {\r\n\t\t\t\tvar error = this.createError(ErrorCodes.OBJECT_REQUIRED, {key: key}, '', '/required/' + i, null, data, schema);\r\n\t\t\t\tif (this.handleError(error)) {\r\n\t\t\t\t\treturn error;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateObjectProperties = function validateObjectProperties(data, schema, dataPointerPath) {\r\n\tvar error;\r\n\tfor (var key in data) {\r\n\t\tvar keyPointerPath = dataPointerPath + \"/\" + key.replace(/~/g, '~0').replace(/\\//g, '~1');\r\n\t\tvar foundMatch = false;\r\n\t\tif (schema.properties !== undefined && schema.properties[key] !== undefined) {\r\n\t\t\tfoundMatch = true;\r\n\t\t\tif (error = this.validateAll(data[key], schema.properties[key], [key], [\"properties\", key], keyPointerPath)) {\r\n\t\t\t\treturn error;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (schema.patternProperties !== undefined) {\r\n\t\t\tfor (var patternKey in schema.patternProperties) {\r\n\t\t\t\tvar regexp = new RegExp(patternKey);\r\n\t\t\t\tif (regexp.test(key)) {\r\n\t\t\t\t\tfoundMatch = true;\r\n\t\t\t\t\tif (error = this.validateAll(data[key], schema.patternProperties[patternKey], [key], [\"patternProperties\", patternKey], keyPointerPath)) {\r\n\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!foundMatch) {\r\n\t\t\tif (schema.additionalProperties !== undefined) {\r\n\t\t\t\tif (this.trackUnknownProperties) {\r\n\t\t\t\t\tthis.knownPropertyPaths[keyPointerPath] = true;\r\n\t\t\t\t\tdelete this.unknownPropertyPaths[keyPointerPath];\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof schema.additionalProperties === \"boolean\") {\r\n\t\t\t\t\tif (!schema.additionalProperties) {\r\n\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_ADDITIONAL_PROPERTIES, {key: key}, '', '/additionalProperties', null, data, schema).prefixWith(key, null);\r\n\t\t\t\t\t\tif (this.handleError(error)) {\r\n\t\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (error = this.validateAll(data[key], schema.additionalProperties, [key], [\"additionalProperties\"], keyPointerPath)) {\r\n\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else if (this.trackUnknownProperties && !this.knownPropertyPaths[keyPointerPath]) {\r\n\t\t\t\tthis.unknownPropertyPaths[keyPointerPath] = true;\r\n\t\t\t}\r\n\t\t} else if (this.trackUnknownProperties) {\r\n\t\t\tthis.knownPropertyPaths[keyPointerPath] = true;\r\n\t\t\tdelete this.unknownPropertyPaths[keyPointerPath];\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateObjectDependencies = function validateObjectDependencies(data, schema, dataPointerPath) {\r\n\tvar error;\r\n\tif (schema.dependencies !== undefined) {\r\n\t\tfor (var depKey in schema.dependencies) {\r\n\t\t\tif (data[depKey] !== undefined) {\r\n\t\t\t\tvar dep = schema.dependencies[depKey];\r\n\t\t\t\tif (typeof dep === \"string\") {\r\n\t\t\t\t\tif (data[dep] === undefined) {\r\n\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: dep}, '', '', null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\r\n\t\t\t\t\t\tif (this.handleError(error)) {\r\n\t\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (Array.isArray(dep)) {\r\n\t\t\t\t\tfor (var i = 0; i < dep.length; i++) {\r\n\t\t\t\t\t\tvar requiredKey = dep[i];\r\n\t\t\t\t\t\tif (data[requiredKey] === undefined) {\r\n\t\t\t\t\t\t\terror = this.createError(ErrorCodes.OBJECT_DEPENDENCY_KEY, {key: depKey, missing: requiredKey}, '', '/' + i, null, data, schema).prefixWith(null, depKey).prefixWith(null, \"dependencies\");\r\n\t\t\t\t\t\t\tif (this.handleError(error)) {\r\n\t\t\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (error = this.validateAll(data, dep, [], [\"dependencies\", depKey], dataPointerPath)) {\r\n\t\t\t\t\t\treturn error;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateCombinations = function validateCombinations(data, schema, dataPointerPath) {\r\n\treturn this.validateAllOf(data, schema, dataPointerPath)\r\n\t\t|| this.validateAnyOf(data, schema, dataPointerPath)\r\n\t\t|| this.validateOneOf(data, schema, dataPointerPath)\r\n\t\t|| this.validateNot(data, schema, dataPointerPath)\r\n\t\t|| null;\r\n};\r\n\r\nValidatorContext.prototype.validateAllOf = function validateAllOf(data, schema, dataPointerPath) {\r\n\tif (schema.allOf === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\tvar error;\r\n\tfor (var i = 0; i < schema.allOf.length; i++) {\r\n\t\tvar subSchema = schema.allOf[i];\r\n\t\tif (error = this.validateAll(data, subSchema, [], [\"allOf\", i], dataPointerPath)) {\r\n\t\t\treturn error;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateAnyOf = function validateAnyOf(data, schema, dataPointerPath) {\r\n\tif (schema.anyOf === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\tvar errors = [];\r\n\tvar startErrorCount = this.errors.length;\r\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\r\n\tif (this.trackUnknownProperties) {\r\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\r\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\r\n\t}\r\n\tvar errorAtEnd = true;\r\n\tfor (var i = 0; i < schema.anyOf.length; i++) {\r\n\t\tif (this.trackUnknownProperties) {\r\n\t\t\tthis.unknownPropertyPaths = {};\r\n\t\t\tthis.knownPropertyPaths = {};\r\n\t\t}\r\n\t\tvar subSchema = schema.anyOf[i];\r\n\r\n\t\tvar errorCount = this.errors.length;\r\n\t\tvar error = this.validateAll(data, subSchema, [], [\"anyOf\", i], dataPointerPath);\r\n\r\n\t\tif (error === null && errorCount === this.errors.length) {\r\n\t\t\tthis.errors = this.errors.slice(0, startErrorCount);\r\n\r\n\t\t\tif (this.trackUnknownProperties) {\r\n\t\t\t\tfor (var knownKey in this.knownPropertyPaths) {\r\n\t\t\t\t\toldKnownPropertyPaths[knownKey] = true;\r\n\t\t\t\t\tdelete oldUnknownPropertyPaths[knownKey];\r\n\t\t\t\t}\r\n\t\t\t\tfor (var unknownKey in this.unknownPropertyPaths) {\r\n\t\t\t\t\tif (!oldKnownPropertyPaths[unknownKey]) {\r\n\t\t\t\t\t\toldUnknownPropertyPaths[unknownKey] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// We need to continue looping so we catch all the property definitions, but we don't want to return an error\r\n\t\t\t\terrorAtEnd = false;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (error) {\r\n\t\t\terrors.push(error.prefixWith(null, \"\" + i).prefixWith(null, \"anyOf\"));\r\n\t\t}\r\n\t}\r\n\tif (this.trackUnknownProperties) {\r\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\r\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\r\n\t}\r\n\tif (errorAtEnd) {\r\n\t\terrors = errors.concat(this.errors.slice(startErrorCount));\r\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\r\n\t\treturn this.createError(ErrorCodes.ANY_OF_MISSING, {}, \"\", \"/anyOf\", errors, data, schema);\r\n\t}\r\n};\r\n\r\nValidatorContext.prototype.validateOneOf = function validateOneOf(data, schema, dataPointerPath) {\r\n\tif (schema.oneOf === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\tvar validIndex = null;\r\n\tvar errors = [];\r\n\tvar startErrorCount = this.errors.length;\r\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\r\n\tif (this.trackUnknownProperties) {\r\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\r\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\r\n\t}\r\n\tfor (var i = 0; i < schema.oneOf.length; i++) {\r\n\t\tif (this.trackUnknownProperties) {\r\n\t\t\tthis.unknownPropertyPaths = {};\r\n\t\t\tthis.knownPropertyPaths = {};\r\n\t\t}\r\n\t\tvar subSchema = schema.oneOf[i];\r\n\r\n\t\tvar errorCount = this.errors.length;\r\n\t\tvar error = this.validateAll(data, subSchema, [], [\"oneOf\", i], dataPointerPath);\r\n\r\n\t\tif (error === null && errorCount === this.errors.length) {\r\n\t\t\tif (validIndex === null) {\r\n\t\t\t\tvalidIndex = i;\r\n\t\t\t} else {\r\n\t\t\t\tthis.errors = this.errors.slice(0, startErrorCount);\r\n\t\t\t\treturn this.createError(ErrorCodes.ONE_OF_MULTIPLE, {index1: validIndex, index2: i}, \"\", \"/oneOf\", null, data, schema);\r\n\t\t\t}\r\n\t\t\tif (this.trackUnknownProperties) {\r\n\t\t\t\tfor (var knownKey in this.knownPropertyPaths) {\r\n\t\t\t\t\toldKnownPropertyPaths[knownKey] = true;\r\n\t\t\t\t\tdelete oldUnknownPropertyPaths[knownKey];\r\n\t\t\t\t}\r\n\t\t\t\tfor (var unknownKey in this.unknownPropertyPaths) {\r\n\t\t\t\t\tif (!oldKnownPropertyPaths[unknownKey]) {\r\n\t\t\t\t\t\toldUnknownPropertyPaths[unknownKey] = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (error) {\r\n\t\t\terrors.push(error);\r\n\t\t}\r\n\t}\r\n\tif (this.trackUnknownProperties) {\r\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\r\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\r\n\t}\r\n\tif (validIndex === null) {\r\n\t\terrors = errors.concat(this.errors.slice(startErrorCount));\r\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\r\n\t\treturn this.createError(ErrorCodes.ONE_OF_MISSING, {}, \"\", \"/oneOf\", errors, data, schema);\r\n\t} else {\r\n\t\tthis.errors = this.errors.slice(0, startErrorCount);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateNot = function validateNot(data, schema, dataPointerPath) {\r\n\tif (schema.not === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\tvar oldErrorCount = this.errors.length;\r\n\tvar oldUnknownPropertyPaths, oldKnownPropertyPaths;\r\n\tif (this.trackUnknownProperties) {\r\n\t\toldUnknownPropertyPaths = this.unknownPropertyPaths;\r\n\t\toldKnownPropertyPaths = this.knownPropertyPaths;\r\n\t\tthis.unknownPropertyPaths = {};\r\n\t\tthis.knownPropertyPaths = {};\r\n\t}\r\n\tvar error = this.validateAll(data, schema.not, null, null, dataPointerPath);\r\n\tvar notErrors = this.errors.slice(oldErrorCount);\r\n\tthis.errors = this.errors.slice(0, oldErrorCount);\r\n\tif (this.trackUnknownProperties) {\r\n\t\tthis.unknownPropertyPaths = oldUnknownPropertyPaths;\r\n\t\tthis.knownPropertyPaths = oldKnownPropertyPaths;\r\n\t}\r\n\tif (error === null && notErrors.length === 0) {\r\n\t\treturn this.createError(ErrorCodes.NOT_PASSED, {}, \"\", \"/not\", null, data, schema);\r\n\t}\r\n\treturn null;\r\n};\r\n\r\nValidatorContext.prototype.validateHypermedia = function validateCombinations(data, schema, dataPointerPath) {\r\n\tif (!schema.links) {\r\n\t\treturn null;\r\n\t}\r\n\tvar error;\r\n\tfor (var i = 0; i < schema.links.length; i++) {\r\n\t\tvar ldo = schema.links[i];\r\n\t\tif (ldo.rel === \"describedby\") {\r\n\t\t\tvar template = new UriTemplate(ldo.href);\r\n\t\t\tvar allPresent = true;\r\n\t\t\tfor (var j = 0; j < template.varNames.length; j++) {\r\n\t\t\t\tif (!(template.varNames[j] in data)) {\r\n\t\t\t\t\tallPresent = false;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (allPresent) {\r\n\t\t\t\tvar schemaUrl = template.fillFromObject(data);\r\n\t\t\t\tvar subSchema = {\"$ref\": schemaUrl};\r\n\t\t\t\tif (error = this.validateAll(data, subSchema, [], [\"links\", i], dataPointerPath)) {\r\n\t\t\t\t\treturn error;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// parseURI() and resolveUrl() are from https://gist.github.com/1088850\r\n//   -  released as public domain by author (\"Yaffle\") - see comments on gist\r\n\r\nfunction parseURI(url) {\r\n\tvar m = String(url).replace(/^\\s+|\\s+$/g, '').match(/^([^:\\/?#]+:)?(\\/\\/(?:[^:@]*(?::[^:@]*)?@)?(([^:\\/?#]*)(?::(\\d*))?))?([^?#]*)(\\?[^#]*)?(#[\\s\\S]*)?/);\r\n\t// authority = '//' + user + ':' + pass '@' + hostname + ':' port\r\n\treturn (m ? {\r\n\t\thref     : m[0] || '',\r\n\t\tprotocol : m[1] || '',\r\n\t\tauthority: m[2] || '',\r\n\t\thost     : m[3] || '',\r\n\t\thostname : m[4] || '',\r\n\t\tport     : m[5] || '',\r\n\t\tpathname : m[6] || '',\r\n\t\tsearch   : m[7] || '',\r\n\t\thash     : m[8] || ''\r\n\t} : null);\r\n}\r\n\r\nfunction resolveUrl(base, href) {// RFC 3986\r\n\r\n\tfunction removeDotSegments(input) {\r\n\t\tvar output = [];\r\n\t\tinput.replace(/^(\\.\\.?(\\/|$))+/, '')\r\n\t\t\t.replace(/\\/(\\.(\\/|$))+/g, '/')\r\n\t\t\t.replace(/\\/\\.\\.$/, '/../')\r\n\t\t\t.replace(/\\/?[^\\/]*/g, function (p) {\r\n\t\t\t\tif (p === '/..') {\r\n\t\t\t\t\toutput.pop();\r\n\t\t\t\t} else {\r\n\t\t\t\t\toutput.push(p);\r\n\t\t\t\t}\r\n\t\t});\r\n\t\treturn output.join('').replace(/^\\//, input.charAt(0) === '/' ? '/' : '');\r\n\t}\r\n\r\n\thref = parseURI(href || '');\r\n\tbase = parseURI(base || '');\r\n\r\n\treturn !href || !base ? null : (href.protocol || base.protocol) +\r\n\t\t(href.protocol || href.authority ? href.authority : base.authority) +\r\n\t\tremoveDotSegments(href.protocol || href.authority || href.pathname.charAt(0) === '/' ? href.pathname : (href.pathname ? ((base.authority && !base.pathname ? '/' : '') + base.pathname.slice(0, base.pathname.lastIndexOf('/') + 1) + href.pathname) : base.pathname)) +\r\n\t\t(href.protocol || href.authority || href.pathname ? href.search : (href.search || base.search)) +\r\n\t\thref.hash;\r\n}\r\n\r\nfunction getDocumentUri(uri) {\r\n\treturn uri.split('#')[0];\r\n}\r\nfunction normSchema(schema, baseUri) {\r\n\tif (schema && typeof schema === \"object\") {\r\n\t\tif (baseUri === undefined) {\r\n\t\t\tbaseUri = schema.id;\r\n\t\t} else if (typeof schema.id === \"string\") {\r\n\t\t\tbaseUri = resolveUrl(baseUri, schema.id);\r\n\t\t\tschema.id = baseUri;\r\n\t\t}\r\n\t\tif (Array.isArray(schema)) {\r\n\t\t\tfor (var i = 0; i < schema.length; i++) {\r\n\t\t\t\tnormSchema(schema[i], baseUri);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tif (typeof schema['$ref'] === \"string\") {\r\n\t\t\t\tschema['$ref'] = resolveUrl(baseUri, schema['$ref']);\r\n\t\t\t}\r\n\t\t\tfor (var key in schema) {\r\n\t\t\t\tif (key !== \"enum\") {\r\n\t\t\t\t\tnormSchema(schema[key], baseUri);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction defaultErrorReporter(language) {\r\n\tlanguage = language || 'en';\r\n\r\n\tvar errorMessages = languages[language];\r\n\r\n\treturn function (error) {\r\n\t\tvar messageTemplate = errorMessages[error.code] || ErrorMessagesDefault[error.code];\r\n\t\tif (typeof messageTemplate !== 'string') {\r\n\t\t\treturn \"Unknown error code \" + error.code + \": \" + JSON.stringify(error.messageParams);\r\n\t\t}\r\n\t\tvar messageParams = error.params;\r\n\t\t// Adapted from Crockford's supplant()\r\n\t\treturn messageTemplate.replace(/\\{([^{}]*)\\}/g, function (whole, varName) {\r\n\t\t\tvar subValue = messageParams[varName];\r\n\t\t\treturn typeof subValue === 'string' || typeof subValue === 'number' ? subValue : whole;\r\n\t\t});\r\n\t};\r\n}\r\n\r\nvar ErrorCodes = {\r\n\tINVALID_TYPE: 0,\r\n\tENUM_MISMATCH: 1,\r\n\tANY_OF_MISSING: 10,\r\n\tONE_OF_MISSING: 11,\r\n\tONE_OF_MULTIPLE: 12,\r\n\tNOT_PASSED: 13,\r\n\t// Numeric errors\r\n\tNUMBER_MULTIPLE_OF: 100,\r\n\tNUMBER_MINIMUM: 101,\r\n\tNUMBER_MINIMUM_EXCLUSIVE: 102,\r\n\tNUMBER_MAXIMUM: 103,\r\n\tNUMBER_MAXIMUM_EXCLUSIVE: 104,\r\n\tNUMBER_NOT_A_NUMBER: 105,\r\n\t// String errors\r\n\tSTRING_LENGTH_SHORT: 200,\r\n\tSTRING_LENGTH_LONG: 201,\r\n\tSTRING_PATTERN: 202,\r\n\t// Object errors\r\n\tOBJECT_PROPERTIES_MINIMUM: 300,\r\n\tOBJECT_PROPERTIES_MAXIMUM: 301,\r\n\tOBJECT_REQUIRED: 302,\r\n\tOBJECT_ADDITIONAL_PROPERTIES: 303,\r\n\tOBJECT_DEPENDENCY_KEY: 304,\r\n\t// Array errors\r\n\tARRAY_LENGTH_SHORT: 400,\r\n\tARRAY_LENGTH_LONG: 401,\r\n\tARRAY_UNIQUE: 402,\r\n\tARRAY_ADDITIONAL_ITEMS: 403,\r\n\t// Custom/user-defined errors\r\n\tFORMAT_CUSTOM: 500,\r\n\tKEYWORD_CUSTOM: 501,\r\n\t// Schema structure\r\n\tCIRCULAR_REFERENCE: 600,\r\n\t// Non-standard validation options\r\n\tUNKNOWN_PROPERTY: 1000\r\n};\r\nvar ErrorCodeLookup = {};\r\nfor (var key in ErrorCodes) {\r\n\tErrorCodeLookup[ErrorCodes[key]] = key;\r\n}\r\nvar ErrorMessagesDefault = {\r\n\tINVALID_TYPE: \"Invalid type: {type} (expected {expected})\",\r\n\tENUM_MISMATCH: \"No enum match for: {value}\",\r\n\tANY_OF_MISSING: \"Data does not match any schemas from \\\"anyOf\\\"\",\r\n\tONE_OF_MISSING: \"Data does not match any schemas from \\\"oneOf\\\"\",\r\n\tONE_OF_MULTIPLE: \"Data is valid against more than one schema from \\\"oneOf\\\": indices {index1} and {index2}\",\r\n\tNOT_PASSED: \"Data matches schema from \\\"not\\\"\",\r\n\t// Numeric errors\r\n\tNUMBER_MULTIPLE_OF: \"Value {value} is not a multiple of {multipleOf}\",\r\n\tNUMBER_MINIMUM: \"Value {value} is less than minimum {minimum}\",\r\n\tNUMBER_MINIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive minimum {minimum}\",\r\n\tNUMBER_MAXIMUM: \"Value {value} is greater than maximum {maximum}\",\r\n\tNUMBER_MAXIMUM_EXCLUSIVE: \"Value {value} is equal to exclusive maximum {maximum}\",\r\n\tNUMBER_NOT_A_NUMBER: \"Value {value} is not a valid number\",\r\n\t// String errors\r\n\tSTRING_LENGTH_SHORT: \"String is too short ({length} chars), minimum {minimum}\",\r\n\tSTRING_LENGTH_LONG: \"String is too long ({length} chars), maximum {maximum}\",\r\n\tSTRING_PATTERN: \"String does not match pattern: {pattern}\",\r\n\t// Object errors\r\n\tOBJECT_PROPERTIES_MINIMUM: \"Too few properties defined ({propertyCount}), minimum {minimum}\",\r\n\tOBJECT_PROPERTIES_MAXIMUM: \"Too many properties defined ({propertyCount}), maximum {maximum}\",\r\n\tOBJECT_REQUIRED: \"Missing required property: {key}\",\r\n\tOBJECT_ADDITIONAL_PROPERTIES: \"Additional properties not allowed\",\r\n\tOBJECT_DEPENDENCY_KEY: \"Dependency failed - key must exist: {missing} (due to key: {key})\",\r\n\t// Array errors\r\n\tARRAY_LENGTH_SHORT: \"Array is too short ({length}), minimum {minimum}\",\r\n\tARRAY_LENGTH_LONG: \"Array is too long ({length}), maximum {maximum}\",\r\n\tARRAY_UNIQUE: \"Array items are not unique (indices {match1} and {match2})\",\r\n\tARRAY_ADDITIONAL_ITEMS: \"Additional items not allowed\",\r\n\t// Format errors\r\n\tFORMAT_CUSTOM: \"Format validation failed ({message})\",\r\n\tKEYWORD_CUSTOM: \"Keyword failed: {key} ({message})\",\r\n\t// Schema structure\r\n\tCIRCULAR_REFERENCE: \"Circular $refs: {urls}\",\r\n\t// Non-standard validation options\r\n\tUNKNOWN_PROPERTY: \"Unknown property (not in schema)\"\r\n};\r\n\r\nfunction ValidationError(code, params, dataPath, schemaPath, subErrors) {\r\n\tError.call(this);\r\n\tif (code === undefined) {\r\n\t\tthrow new Error (\"No error code supplied: \" + schemaPath);\r\n\t}\r\n\tthis.message = '';\r\n\tthis.params = params;\r\n\tthis.code = code;\r\n\tthis.dataPath = dataPath || \"\";\r\n\tthis.schemaPath = schemaPath || \"\";\r\n\tthis.subErrors = subErrors || null;\r\n\r\n\tvar err = new Error(this.message);\r\n\tthis.stack = err.stack || err.stacktrace;\r\n\tif (!this.stack) {\r\n\t\ttry {\r\n\t\t\tthrow err;\r\n\t\t}\r\n\t\tcatch(err) {\r\n\t\t\tthis.stack = err.stack || err.stacktrace;\r\n\t\t}\r\n\t}\r\n}\r\nValidationError.prototype = Object.create(Error.prototype);\r\nValidationError.prototype.constructor = ValidationError;\r\nValidationError.prototype.name = 'ValidationError';\r\n\r\nValidationError.prototype.prefixWith = function (dataPrefix, schemaPrefix) {\r\n\tif (dataPrefix !== null) {\r\n\t\tdataPrefix = dataPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\r\n\t\tthis.dataPath = \"/\" + dataPrefix + this.dataPath;\r\n\t}\r\n\tif (schemaPrefix !== null) {\r\n\t\tschemaPrefix = schemaPrefix.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\r\n\t\tthis.schemaPath = \"/\" + schemaPrefix + this.schemaPath;\r\n\t}\r\n\tif (this.subErrors !== null) {\r\n\t\tfor (var i = 0; i < this.subErrors.length; i++) {\r\n\t\t\tthis.subErrors[i].prefixWith(dataPrefix, schemaPrefix);\r\n\t\t}\r\n\t}\r\n\treturn this;\r\n};\r\n\r\nfunction isTrustedUrl(baseUrl, testUrl) {\r\n\tif(testUrl.substring(0, baseUrl.length) === baseUrl){\r\n\t\tvar remainder = testUrl.substring(baseUrl.length);\r\n\t\tif ((testUrl.length > 0 && testUrl.charAt(baseUrl.length - 1) === \"/\")\r\n\t\t\t|| remainder.charAt(0) === \"#\"\r\n\t\t\t|| remainder.charAt(0) === \"?\") {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nvar languages = {};\r\nfunction createApi(language) {\r\n\tvar globalContext = new ValidatorContext();\r\n\tvar currentLanguage;\r\n\tvar customErrorReporter;\r\n\tvar api = {\r\n\t\tsetErrorReporter: function (reporter) {\r\n\t\t\tif (typeof reporter === 'string') {\r\n\t\t\t\treturn this.language(reporter);\r\n\t\t\t}\r\n\t\t\tcustomErrorReporter = reporter;\r\n\t\t\treturn true;\r\n\t\t},\r\n\t\taddFormat: function () {\r\n\t\t\tglobalContext.addFormat.apply(globalContext, arguments);\r\n\t\t},\r\n\t\tlanguage: function (code) {\r\n\t\t\tif (!code) {\r\n\t\t\t\treturn currentLanguage;\r\n\t\t\t}\r\n\t\t\tif (!languages[code]) {\r\n\t\t\t\tcode = code.split('-')[0]; // fall back to base language\r\n\t\t\t}\r\n\t\t\tif (languages[code]) {\r\n\t\t\t\tcurrentLanguage = code;\r\n\t\t\t\treturn code; // so you can tell if fall-back has happened\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\taddLanguage: function (code, messageMap) {\r\n\t\t\tvar key;\r\n\t\t\tfor (key in ErrorCodes) {\r\n\t\t\t\tif (messageMap[key] && !messageMap[ErrorCodes[key]]) {\r\n\t\t\t\t\tmessageMap[ErrorCodes[key]] = messageMap[key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tvar rootCode = code.split('-')[0];\r\n\t\t\tif (!languages[rootCode]) { // use for base language if not yet defined\r\n\t\t\t\tlanguages[code] = messageMap;\r\n\t\t\t\tlanguages[rootCode] = messageMap;\r\n\t\t\t} else {\r\n\t\t\t\tlanguages[code] = Object.create(languages[rootCode]);\r\n\t\t\t\tfor (key in messageMap) {\r\n\t\t\t\t\tif (typeof languages[rootCode][key] === 'undefined') {\r\n\t\t\t\t\t\tlanguages[rootCode][key] = messageMap[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlanguages[code][key] = messageMap[key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\tfreshApi: function (language) {\r\n\t\t\tvar result = createApi();\r\n\t\t\tif (language) {\r\n\t\t\t\tresult.language(language);\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tvalidate: function (data, schema, checkRecursive, banUnknownProperties) {\r\n\t\t\tvar def = defaultErrorReporter(currentLanguage);\r\n\t\t\tvar errorReporter = customErrorReporter ? function (error, data, schema) {\r\n\t\t\t\treturn customErrorReporter(error, data, schema) || def(error, data, schema);\r\n\t\t\t} : def;\r\n\t\t\tvar context = new ValidatorContext(globalContext, false, errorReporter, checkRecursive, banUnknownProperties);\r\n\t\t\tif (typeof schema === \"string\") {\r\n\t\t\t\tschema = {\"$ref\": schema};\r\n\t\t\t}\r\n\t\t\tcontext.addSchema(\"\", schema);\r\n\t\t\tvar error = context.validateAll(data, schema, null, null, \"\");\r\n\t\t\tif (!error && banUnknownProperties) {\r\n\t\t\t\terror = context.banUnknownProperties(data, schema);\r\n\t\t\t}\r\n\t\t\tthis.error = error;\r\n\t\t\tthis.missing = context.missing;\r\n\t\t\tthis.valid = (error === null);\r\n\t\t\treturn this.valid;\r\n\t\t},\r\n\t\tvalidateResult: function () {\r\n\t\t\tvar result = {toString: function () {\r\n\t\t\t\treturn this.valid ? 'valid' : this.error.message;\r\n\t\t\t}};\r\n\t\t\tthis.validate.apply(result, arguments);\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\tvalidateMultiple: function (data, schema, checkRecursive, banUnknownProperties) {\r\n\t\t\tvar def = defaultErrorReporter(currentLanguage);\r\n\t\t\tvar errorReporter = customErrorReporter ? function (error, data, schema) {\r\n\t\t\t\treturn customErrorReporter(error, data, schema) || def(error, data, schema);\r\n\t\t\t} : def;\r\n\t\t\tvar context = new ValidatorContext(globalContext, true, errorReporter, checkRecursive, banUnknownProperties);\r\n\t\t\tif (typeof schema === \"string\") {\r\n\t\t\t\tschema = {\"$ref\": schema};\r\n\t\t\t}\r\n\t\t\tcontext.addSchema(\"\", schema);\r\n\t\t\tcontext.validateAll(data, schema, null, null, \"\");\r\n\t\t\tif (banUnknownProperties) {\r\n\t\t\t\tcontext.banUnknownProperties(data, schema);\r\n\t\t\t}\r\n\t\t\tvar result = {toString: function () {\r\n\t\t\t\treturn this.valid ? 'valid' : this.error.message;\r\n\t\t\t}};\r\n\t\t\tresult.errors = context.errors;\r\n\t\t\tresult.missing = context.missing;\r\n\t\t\tresult.valid = (result.errors.length === 0);\r\n\t\t\treturn result;\r\n\t\t},\r\n\t\taddSchema: function () {\r\n\t\t\treturn globalContext.addSchema.apply(globalContext, arguments);\r\n\t\t},\r\n\t\tgetSchema: function () {\r\n\t\t\treturn globalContext.getSchema.apply(globalContext, arguments);\r\n\t\t},\r\n\t\tgetSchemaMap: function () {\r\n\t\t\treturn globalContext.getSchemaMap.apply(globalContext, arguments);\r\n\t\t},\r\n\t\tgetSchemaUris: function () {\r\n\t\t\treturn globalContext.getSchemaUris.apply(globalContext, arguments);\r\n\t\t},\r\n\t\tgetMissingUris: function () {\r\n\t\t\treturn globalContext.getMissingUris.apply(globalContext, arguments);\r\n\t\t},\r\n\t\tdropSchemas: function () {\r\n\t\t\tglobalContext.dropSchemas.apply(globalContext, arguments);\r\n\t\t},\r\n\t\tdefineKeyword: function () {\r\n\t\t\tglobalContext.defineKeyword.apply(globalContext, arguments);\r\n\t\t},\r\n\t\tdefineError: function (codeName, codeNumber, defaultMessage) {\r\n\t\t\tif (typeof codeName !== 'string' || !/^[A-Z]+(_[A-Z]+)*$/.test(codeName)) {\r\n\t\t\t\tthrow new Error('Code name must be a string in UPPER_CASE_WITH_UNDERSCORES');\r\n\t\t\t}\r\n\t\t\tif (typeof codeNumber !== 'number' || codeNumber%1 !== 0 || codeNumber < 10000) {\r\n\t\t\t\tthrow new Error('Code number must be an integer > 10000');\r\n\t\t\t}\r\n\t\t\tif (typeof ErrorCodes[codeName] !== 'undefined') {\r\n\t\t\t\tthrow new Error('Error already defined: ' + codeName + ' as ' + ErrorCodes[codeName]);\r\n\t\t\t}\r\n\t\t\tif (typeof ErrorCodeLookup[codeNumber] !== 'undefined') {\r\n\t\t\t\tthrow new Error('Error code already used: ' + ErrorCodeLookup[codeNumber] + ' as ' + codeNumber);\r\n\t\t\t}\r\n\t\t\tErrorCodes[codeName] = codeNumber;\r\n\t\t\tErrorCodeLookup[codeNumber] = codeName;\r\n\t\t\tErrorMessagesDefault[codeName] = ErrorMessagesDefault[codeNumber] = defaultMessage;\r\n\t\t\tfor (var langCode in languages) {\r\n\t\t\t\tvar language = languages[langCode];\r\n\t\t\t\tif (language[codeName]) {\r\n\t\t\t\t\tlanguage[codeNumber] = language[codeNumber] || language[codeName];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\treset: function () {\r\n\t\t\tglobalContext.reset();\r\n\t\t\tthis.error = null;\r\n\t\t\tthis.missing = [];\r\n\t\t\tthis.valid = true;\r\n\t\t},\r\n\t\tmissing: [],\r\n\t\terror: null,\r\n\t\tvalid: true,\r\n\t\tnormSchema: normSchema,\r\n\t\tresolveUrl: resolveUrl,\r\n\t\tgetDocumentUri: getDocumentUri,\r\n\t\terrorCodes: ErrorCodes\r\n\t};\r\n\tapi.language(language || 'en');\r\n\treturn api;\r\n}\r\n\r\nvar tv4 = createApi();\r\ntv4.addLanguage('en-gb', ErrorMessagesDefault);\r\n\r\n//legacy property\r\ntv4.tv4 = tv4;\r\n\r\nreturn tv4; // used by _header.js to globalise.\r\n\r\n}));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/tv4/tv4.js\n// module id = 12\n// module chunks = 0"],"sourceRoot":""}